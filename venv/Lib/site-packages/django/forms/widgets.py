"""
HTML Widget classes
"""

import copy
import datetime
import warnings
from collections import defaultdict
<<<<<<< HEAD
=======
from graphlib import CycleError, TopologicalSorter
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
from itertools import chain

from django.forms.utils import to_current_timezone
from django.templatetags.static import static
<<<<<<< HEAD
from django.utils import datetime_safe, formats
from django.utils.datastructures import OrderedSet
=======
from django.utils import formats
from django.utils.choices import normalize_choices
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
from django.utils.dates import MONTHS
from django.utils.formats import get_format
from django.utils.html import format_html, html_safe
from django.utils.regex_helper import _lazy_re_compile
from django.utils.safestring import mark_safe
<<<<<<< HEAD
from django.utils.topological_sort import (
    CyclicDependencyError, stable_topological_sort,
)
=======
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
from django.utils.translation import gettext_lazy as _

from .renderers import get_default_renderer

__all__ = (
<<<<<<< HEAD
    'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput',
    'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput',
    'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea',
    'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select',
    'NullBooleanSelect', 'SelectMultiple', 'RadioSelect',
    'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget',
    'SplitHiddenDateTimeWidget', 'SelectDateWidget',
)

MEDIA_TYPES = ('css', 'js')
=======
    "Media",
    "MediaDefiningClass",
    "Widget",
    "TextInput",
    "NumberInput",
    "EmailInput",
    "URLInput",
    "PasswordInput",
    "HiddenInput",
    "MultipleHiddenInput",
    "FileInput",
    "ClearableFileInput",
    "Textarea",
    "DateInput",
    "DateTimeInput",
    "TimeInput",
    "CheckboxInput",
    "Select",
    "NullBooleanSelect",
    "SelectMultiple",
    "RadioSelect",
    "CheckboxSelectMultiple",
    "MultiWidget",
    "SplitDateTimeWidget",
    "SplitHiddenDateTimeWidget",
    "SelectDateWidget",
)

MEDIA_TYPES = ("css", "js")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class MediaOrderConflictWarning(RuntimeWarning):
    pass


@html_safe
class Media:
    def __init__(self, media=None, css=None, js=None):
        if media is not None:
<<<<<<< HEAD
            css = getattr(media, 'css', {})
            js = getattr(media, 'js', [])
=======
            css = getattr(media, "css", {})
            js = getattr(media, "js", [])
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        else:
            if css is None:
                css = {}
            if js is None:
                js = []
        self._css_lists = [css]
        self._js_lists = [js]

    def __repr__(self):
<<<<<<< HEAD
        return 'Media(css=%r, js=%r)' % (self._css, self._js)
=======
        return "Media(css=%r, js=%r)" % (self._css, self._js)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __str__(self):
        return self.render()

    @property
    def _css(self):
        css = defaultdict(list)
        for css_list in self._css_lists:
            for medium, sublist in css_list.items():
                css[medium].append(sublist)
        return {medium: self.merge(*lists) for medium, lists in css.items()}

    @property
    def _js(self):
        return self.merge(*self._js_lists)

    def render(self):
<<<<<<< HEAD
        return mark_safe('\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))

    def render_js(self):
        return [
            format_html(
                '<script src="{}"></script>',
                self.absolute_path(path)
            ) for path in self._js
=======
        return mark_safe(
            "\n".join(
                chain.from_iterable(
                    getattr(self, "render_" + name)() for name in MEDIA_TYPES
                )
            )
        )

    def render_js(self):
        return [
            (
                path.__html__()
                if hasattr(path, "__html__")
                else format_html('<script src="{}"></script>', self.absolute_path(path))
            )
            for path in self._js
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        ]

    def render_css(self):
        # To keep rendering order consistent, we can't just iterate over items().
        # We need to sort the keys, and iterate over the sorted list.
        media = sorted(self._css)
<<<<<<< HEAD
        return chain.from_iterable([
            format_html(
                '<link href="{}" type="text/css" media="{}" rel="stylesheet">',
                self.absolute_path(path), medium
            ) for path in self._css[medium]
        ] for medium in media)
=======
        return chain.from_iterable(
            [
                (
                    path.__html__()
                    if hasattr(path, "__html__")
                    else format_html(
                        '<link href="{}" media="{}" rel="stylesheet">',
                        self.absolute_path(path),
                        medium,
                    )
                )
                for path in self._css[medium]
            ]
            for medium in media
        )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def absolute_path(self, path):
        """
        Given a relative or absolute path to a static asset, return an absolute
        path. An absolute path will be returned unchanged while a relative path
        will be passed to django.templatetags.static.static().
        """
<<<<<<< HEAD
        if path.startswith(('http://', 'https://', '/')):
=======
        if path.startswith(("http://", "https://", "/")):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            return path
        return static(path)

    def __getitem__(self, name):
        """Return a Media object that only contains media of the given type."""
        if name in MEDIA_TYPES:
<<<<<<< HEAD
            return Media(**{str(name): getattr(self, '_' + name)})
=======
            return Media(**{str(name): getattr(self, "_" + name)})
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        raise KeyError('Unknown media type "%s"' % name)

    @staticmethod
    def merge(*lists):
        """
        Merge lists while trying to keep the relative order of the elements.
        Warn if the lists have the same elements in a different relative order.

        For static assets it can be important to have them included in the DOM
        in a certain order. In JavaScript you may not be able to reference a
        global or in CSS you might want to override a style.
        """
<<<<<<< HEAD
        dependency_graph = defaultdict(set)
        all_items = OrderedSet()
        for list_ in filter(None, lists):
            head = list_[0]
            # The first items depend on nothing but have to be part of the
            # dependency graph to be included in the result.
            dependency_graph.setdefault(head, set())
            for item in list_:
                all_items.add(item)
                # No self dependencies
                if head != item:
                    dependency_graph[item].add(head)
                head = item
        try:
            return stable_topological_sort(all_items, dependency_graph)
        except CyclicDependencyError:
            warnings.warn(
                'Detected duplicate Media files in an opposite order: {}'.format(
                    ', '.join(repr(list_) for list_ in lists)
                ), MediaOrderConflictWarning,
            )
            return list(all_items)
=======
        ts = TopologicalSorter()
        for head, *tail in filter(None, lists):
            ts.add(head)  # Ensure that the first items are included.
            for item in tail:
                if head != item:  # Avoid circular dependency to self.
                    ts.add(item, head)
                head = item
        try:
            return list(ts.static_order())
        except CycleError:
            warnings.warn(
                "Detected duplicate Media files in an opposite order: {}".format(
                    ", ".join(repr(list_) for list_ in lists)
                ),
                MediaOrderConflictWarning,
            )
            return list(dict.fromkeys(chain.from_iterable(filter(None, lists))))
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __add__(self, other):
        combined = Media()
        combined._css_lists = self._css_lists[:]
        combined._js_lists = self._js_lists[:]
        for item in other._css_lists:
            if item and item not in self._css_lists:
                combined._css_lists.append(item)
        for item in other._js_lists:
            if item and item not in self._js_lists:
                combined._js_lists.append(item)
        return combined


def media_property(cls):
    def _media(self):
        # Get the media property of the superclass, if it exists
        sup_cls = super(cls, self)
        try:
            base = sup_cls.media
        except AttributeError:
            base = Media()

        # Get the media definition for this class
<<<<<<< HEAD
        definition = getattr(cls, 'Media', None)
        if definition:
            extend = getattr(definition, 'extend', True)
=======
        definition = getattr(cls, "Media", None)
        if definition:
            extend = getattr(definition, "extend", True)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            if extend:
                if extend is True:
                    m = base
                else:
                    m = Media()
                    for medium in extend:
<<<<<<< HEAD
                        m = m + base[medium]
                return m + Media(definition)
            return Media(definition)
        return base
=======
                        m += base[medium]
                return m + Media(definition)
            return Media(definition)
        return base

>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    return property(_media)


class MediaDefiningClass(type):
    """
    Metaclass for classes that can have media definitions.
    """
<<<<<<< HEAD
    def __new__(mcs, name, bases, attrs):
        new_class = super().__new__(mcs, name, bases, attrs)

        if 'media' not in attrs:
=======

    def __new__(mcs, name, bases, attrs):
        new_class = super().__new__(mcs, name, bases, attrs)

        if "media" not in attrs:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            new_class.media = media_property(new_class)

        return new_class


class Widget(metaclass=MediaDefiningClass):
    needs_multipart_form = False  # Determines does this widget need multipart form
    is_localized = False
    is_required = False
    supports_microseconds = True
<<<<<<< HEAD
=======
    use_fieldset = False
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, attrs=None):
        self.attrs = {} if attrs is None else attrs.copy()

    def __deepcopy__(self, memo):
        obj = copy.copy(self)
        obj.attrs = self.attrs.copy()
        memo[id(self)] = obj
        return obj

    @property
    def is_hidden(self):
<<<<<<< HEAD
        return self.input_type == 'hidden' if hasattr(self, 'input_type') else False

    def subwidgets(self, name, value, attrs=None):
        context = self.get_context(name, value, attrs)
        yield context['widget']
=======
        return self.input_type == "hidden" if hasattr(self, "input_type") else False

    def subwidgets(self, name, value, attrs=None):
        context = self.get_context(name, value, attrs)
        yield context["widget"]
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def format_value(self, value):
        """
        Return a value as it should appear when rendered in a template.
        """
<<<<<<< HEAD
        if value == '' or value is None:
=======
        if value == "" or value is None:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            return None
        if self.is_localized:
            return formats.localize_input(value)
        return str(value)

    def get_context(self, name, value, attrs):
        return {
<<<<<<< HEAD
            'widget': {
                'name': name,
                'is_hidden': self.is_hidden,
                'required': self.is_required,
                'value': self.format_value(value),
                'attrs': self.build_attrs(self.attrs, attrs),
                'template_name': self.template_name,
=======
            "widget": {
                "name": name,
                "is_hidden": self.is_hidden,
                "required": self.is_required,
                "value": self.format_value(value),
                "attrs": self.build_attrs(self.attrs, attrs),
                "template_name": self.template_name,
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            },
        }

    def render(self, name, value, attrs=None, renderer=None):
        """Render the widget as an HTML string."""
        context = self.get_context(name, value, attrs)
        return self._render(self.template_name, context, renderer)

    def _render(self, template_name, context, renderer=None):
        if renderer is None:
            renderer = get_default_renderer()
        return mark_safe(renderer.render(template_name, context))

    def build_attrs(self, base_attrs, extra_attrs=None):
        """Build an attribute dictionary."""
        return {**base_attrs, **(extra_attrs or {})}

    def value_from_datadict(self, data, files, name):
        """
        Given a dictionary of data and this widget's name, return the value
        of this widget or None if it's not provided.
        """
        return data.get(name)

    def value_omitted_from_data(self, data, files, name):
        return name not in data

    def id_for_label(self, id_):
        """
<<<<<<< HEAD
        Return the HTML ID attribute of this Widget for use by a <label>,
        given the ID of the field. Return None if no ID is available.
=======
        Return the HTML ID attribute of this Widget for use by a <label>, given
        the ID of the field. Return an empty string if no ID is available.
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        This hook is necessary because some widgets have multiple HTML
        elements and, thus, multiple IDs. In that case, this method should
        return an ID value that corresponds to the first ID in the widget's
        tags.
        """
        return id_

    def use_required_attribute(self, initial):
        return not self.is_hidden


class Input(Widget):
    """
    Base class for all <input> widgets.
    """
<<<<<<< HEAD
    input_type = None  # Subclasses must define this.
    template_name = 'django/forms/widgets/input.html'
=======

    input_type = None  # Subclasses must define this.
    template_name = "django/forms/widgets/input.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, attrs=None):
        if attrs is not None:
            attrs = attrs.copy()
<<<<<<< HEAD
            self.input_type = attrs.pop('type', self.input_type)
=======
            self.input_type = attrs.pop("type", self.input_type)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        super().__init__(attrs)

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
<<<<<<< HEAD
        context['widget']['type'] = self.input_type
=======
        context["widget"]["type"] = self.input_type
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return context


class TextInput(Input):
<<<<<<< HEAD
    input_type = 'text'
    template_name = 'django/forms/widgets/text.html'


class NumberInput(Input):
    input_type = 'number'
    template_name = 'django/forms/widgets/number.html'


class EmailInput(Input):
    input_type = 'email'
    template_name = 'django/forms/widgets/email.html'


class URLInput(Input):
    input_type = 'url'
    template_name = 'django/forms/widgets/url.html'


class PasswordInput(Input):
    input_type = 'password'
    template_name = 'django/forms/widgets/password.html'
=======
    input_type = "text"
    template_name = "django/forms/widgets/text.html"


class NumberInput(Input):
    input_type = "number"
    template_name = "django/forms/widgets/number.html"


class EmailInput(Input):
    input_type = "email"
    template_name = "django/forms/widgets/email.html"


class URLInput(Input):
    input_type = "url"
    template_name = "django/forms/widgets/url.html"


class PasswordInput(Input):
    input_type = "password"
    template_name = "django/forms/widgets/password.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, attrs=None, render_value=False):
        super().__init__(attrs)
        self.render_value = render_value

    def get_context(self, name, value, attrs):
        if not self.render_value:
            value = None
        return super().get_context(name, value, attrs)


class HiddenInput(Input):
<<<<<<< HEAD
    input_type = 'hidden'
    template_name = 'django/forms/widgets/hidden.html'
=======
    input_type = "hidden"
    template_name = "django/forms/widgets/hidden.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class MultipleHiddenInput(HiddenInput):
    """
    Handle <input type="hidden"> for fields that have a list
    of values.
    """
<<<<<<< HEAD
    template_name = 'django/forms/widgets/multiple_hidden.html'

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        final_attrs = context['widget']['attrs']
        id_ = context['widget']['attrs'].get('id')

        subwidgets = []
        for index, value_ in enumerate(context['widget']['value']):
=======

    template_name = "django/forms/widgets/multiple_hidden.html"

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        final_attrs = context["widget"]["attrs"]
        id_ = context["widget"]["attrs"].get("id")

        subwidgets = []
        for index, value_ in enumerate(context["widget"]["value"]):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            widget_attrs = final_attrs.copy()
            if id_:
                # An ID attribute was given. Add a numeric index as a suffix
                # so that the inputs don't all have the same ID attribute.
<<<<<<< HEAD
                widget_attrs['id'] = '%s_%s' % (id_, index)
            widget = HiddenInput()
            widget.is_required = self.is_required
            subwidgets.append(widget.get_context(name, value_, widget_attrs)['widget'])

        context['widget']['subwidgets'] = subwidgets
=======
                widget_attrs["id"] = "%s_%s" % (id_, index)
            widget = HiddenInput()
            widget.is_required = self.is_required
            subwidgets.append(widget.get_context(name, value_, widget_attrs)["widget"])

        context["widget"]["subwidgets"] = subwidgets
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return context

    def value_from_datadict(self, data, files, name):
        try:
            getter = data.getlist
        except AttributeError:
            getter = data.get
        return getter(name)

    def format_value(self, value):
        return [] if value is None else value


class FileInput(Input):
<<<<<<< HEAD
    input_type = 'file'
    needs_multipart_form = True
    template_name = 'django/forms/widgets/file.html'
=======
    allow_multiple_selected = False
    input_type = "file"
    needs_multipart_form = True
    template_name = "django/forms/widgets/file.html"

    def __init__(self, attrs=None):
        if (
            attrs is not None
            and not self.allow_multiple_selected
            and attrs.get("multiple", False)
        ):
            raise ValueError(
                "%s doesn't support uploading multiple files."
                % self.__class__.__qualname__
            )
        if self.allow_multiple_selected:
            if attrs is None:
                attrs = {"multiple": True}
            else:
                attrs.setdefault("multiple", True)
        super().__init__(attrs)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def format_value(self, value):
        """File input never renders a value."""
        return

    def value_from_datadict(self, data, files, name):
        "File widgets take data from FILES, not POST"
<<<<<<< HEAD
        return files.get(name)
=======
        getter = files.get
        if self.allow_multiple_selected:
            try:
                getter = files.getlist
            except AttributeError:
                pass
        return getter(name)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def value_omitted_from_data(self, data, files, name):
        return name not in files

    def use_required_attribute(self, initial):
        return super().use_required_attribute(initial) and not initial


FILE_INPUT_CONTRADICTION = object()


class ClearableFileInput(FileInput):
<<<<<<< HEAD
    clear_checkbox_label = _('Clear')
    initial_text = _('Currently')
    input_text = _('Change')
    template_name = 'django/forms/widgets/clearable_file_input.html'
=======
    clear_checkbox_label = _("Clear")
    initial_text = _("Currently")
    input_text = _("Change")
    template_name = "django/forms/widgets/clearable_file_input.html"
    checked = False
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def clear_checkbox_name(self, name):
        """
        Given the name of the file input, return the name of the clear checkbox
        input.
        """
<<<<<<< HEAD
        return name + '-clear'
=======
        return name + "-clear"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def clear_checkbox_id(self, name):
        """
        Given the name of the clear checkbox input, return the HTML id for it.
        """
<<<<<<< HEAD
        return name + '_id'
=======
        return name + "_id"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def is_initial(self, value):
        """
        Return whether value is considered to be initial value.
        """
<<<<<<< HEAD
        return bool(value and getattr(value, 'url', False))
=======
        return bool(value and getattr(value, "url", False))
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def format_value(self, value):
        """
        Return the file object if it has a defined url attribute.
        """
        if self.is_initial(value):
            return value

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        checkbox_name = self.clear_checkbox_name(name)
        checkbox_id = self.clear_checkbox_id(checkbox_name)
<<<<<<< HEAD
        context['widget'].update({
            'checkbox_name': checkbox_name,
            'checkbox_id': checkbox_id,
            'is_initial': self.is_initial(value),
            'input_text': self.input_text,
            'initial_text': self.initial_text,
            'clear_checkbox_label': self.clear_checkbox_label,
        })
=======
        context["widget"].update(
            {
                "checkbox_name": checkbox_name,
                "checkbox_id": checkbox_id,
                "is_initial": self.is_initial(value),
                "input_text": self.input_text,
                "initial_text": self.initial_text,
                "clear_checkbox_label": self.clear_checkbox_label,
            }
        )
        context["widget"]["attrs"].setdefault("disabled", False)
        context["widget"]["attrs"]["checked"] = self.checked
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return context

    def value_from_datadict(self, data, files, name):
        upload = super().value_from_datadict(data, files, name)
<<<<<<< HEAD
        if not self.is_required and CheckboxInput().value_from_datadict(
                data, files, self.clear_checkbox_name(name)):

=======
        self.checked = self.clear_checkbox_name(name) in data
        if not self.is_required and CheckboxInput().value_from_datadict(
            data, files, self.clear_checkbox_name(name)
        ):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            if upload:
                # If the user contradicts themselves (uploads a new file AND
                # checks the "clear" checkbox), we return a unique marker
                # object that FileField will turn into a ValidationError.
                return FILE_INPUT_CONTRADICTION
            # False signals to clear any existing value, as opposed to just None
            return False
        return upload

    def value_omitted_from_data(self, data, files, name):
        return (
<<<<<<< HEAD
            super().value_omitted_from_data(data, files, name) and
            self.clear_checkbox_name(name) not in data
=======
            super().value_omitted_from_data(data, files, name)
            and self.clear_checkbox_name(name) not in data
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )


class Textarea(Widget):
<<<<<<< HEAD
    template_name = 'django/forms/widgets/textarea.html'

    def __init__(self, attrs=None):
        # Use slightly better defaults than HTML's 20x2 box
        default_attrs = {'cols': '40', 'rows': '10'}
=======
    template_name = "django/forms/widgets/textarea.html"

    def __init__(self, attrs=None):
        # Use slightly better defaults than HTML's 20x2 box
        default_attrs = {"cols": "40", "rows": "10"}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        if attrs:
            default_attrs.update(attrs)
        super().__init__(default_attrs)


class DateTimeBaseInput(TextInput):
<<<<<<< HEAD
    format_key = ''
=======
    format_key = ""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    supports_microseconds = False

    def __init__(self, attrs=None, format=None):
        super().__init__(attrs)
        self.format = format or None

    def format_value(self, value):
<<<<<<< HEAD
        return formats.localize_input(value, self.format or formats.get_format(self.format_key)[0])


class DateInput(DateTimeBaseInput):
    format_key = 'DATE_INPUT_FORMATS'
    template_name = 'django/forms/widgets/date.html'


class DateTimeInput(DateTimeBaseInput):
    format_key = 'DATETIME_INPUT_FORMATS'
    template_name = 'django/forms/widgets/datetime.html'


class TimeInput(DateTimeBaseInput):
    format_key = 'TIME_INPUT_FORMATS'
    template_name = 'django/forms/widgets/time.html'
=======
        return formats.localize_input(
            value, self.format or formats.get_format(self.format_key)[0]
        )


class DateInput(DateTimeBaseInput):
    format_key = "DATE_INPUT_FORMATS"
    template_name = "django/forms/widgets/date.html"


class DateTimeInput(DateTimeBaseInput):
    format_key = "DATETIME_INPUT_FORMATS"
    template_name = "django/forms/widgets/datetime.html"


class TimeInput(DateTimeBaseInput):
    format_key = "TIME_INPUT_FORMATS"
    template_name = "django/forms/widgets/time.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


# Defined at module level so that CheckboxInput is picklable (#17976)
def boolean_check(v):
<<<<<<< HEAD
    return not (v is False or v is None or v == '')


class CheckboxInput(Input):
    input_type = 'checkbox'
    template_name = 'django/forms/widgets/checkbox.html'
=======
    return not (v is False or v is None or v == "")


class CheckboxInput(Input):
    input_type = "checkbox"
    template_name = "django/forms/widgets/checkbox.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, attrs=None, check_test=None):
        super().__init__(attrs)
        # check_test is a callable that takes a value and returns True
        # if the checkbox should be checked for that value.
        self.check_test = boolean_check if check_test is None else check_test

    def format_value(self, value):
        """Only return the 'value' attribute if value isn't empty."""
<<<<<<< HEAD
        if value is True or value is False or value is None or value == '':
=======
        if value is True or value is False or value is None or value == "":
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            return
        return str(value)

    def get_context(self, name, value, attrs):
        if self.check_test(value):
<<<<<<< HEAD
            attrs = {**(attrs or {}), 'checked': True}
=======
            attrs = {**(attrs or {}), "checked": True}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return super().get_context(name, value, attrs)

    def value_from_datadict(self, data, files, name):
        if name not in data:
            # A missing value means False because HTML form submission does not
            # send results for unselected checkboxes.
            return False
        value = data.get(name)
        # Translate true and false strings to boolean values.
<<<<<<< HEAD
        values = {'true': True, 'false': False}
=======
        values = {"true": True, "false": False}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        if isinstance(value, str):
            value = values.get(value.lower(), value)
        return bool(value)

    def value_omitted_from_data(self, data, files, name):
        # HTML checkboxes don't appear in POST data if not checked, so it's
        # never known if the value is actually omitted.
        return False


class ChoiceWidget(Widget):
    allow_multiple_selected = False
    input_type = None
    template_name = None
    option_template_name = None
    add_id_index = True
<<<<<<< HEAD
    checked_attribute = {'checked': True}
=======
    checked_attribute = {"checked": True}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    option_inherits_attrs = True

    def __init__(self, attrs=None, choices=()):
        super().__init__(attrs)
<<<<<<< HEAD
        # choices can be any iterable, but we may need to render this widget
        # multiple times. Thus, collapse it into a list so it can be consumed
        # more than once.
        self.choices = list(choices)
=======
        self.choices = choices
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __deepcopy__(self, memo):
        obj = copy.copy(self)
        obj.attrs = self.attrs.copy()
        obj.choices = copy.copy(self.choices)
        memo[id(self)] = obj
        return obj

    def subwidgets(self, name, value, attrs=None):
        """
        Yield all "subwidgets" of this widget. Used to enable iterating
        options from a BoundField for choice widgets.
        """
        value = self.format_value(value)
        yield from self.options(name, value, attrs)

    def options(self, name, value, attrs=None):
<<<<<<< HEAD
        """Yield a flat list of options for this widgets."""
=======
        """Yield a flat list of options for this widget."""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        for group in self.optgroups(name, value, attrs):
            yield from group[1]

    def optgroups(self, name, value, attrs=None):
        """Return a list of optgroups for this widget."""
        groups = []
        has_selected = False

        for index, (option_value, option_label) in enumerate(self.choices):
            if option_value is None:
<<<<<<< HEAD
                option_value = ''
=======
                option_value = ""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

            subgroup = []
            if isinstance(option_label, (list, tuple)):
                group_name = option_value
                subindex = 0
                choices = option_label
            else:
                group_name = None
                subindex = None
                choices = [(option_value, option_label)]
            groups.append((group_name, subgroup, index))

            for subvalue, sublabel in choices:
<<<<<<< HEAD
                selected = (
                    str(subvalue) in value and
                    (not has_selected or self.allow_multiple_selected)
                )
                has_selected |= selected
                subgroup.append(self.create_option(
                    name, subvalue, sublabel, selected, index,
                    subindex=subindex, attrs=attrs,
                ))
=======
                selected = (not has_selected or self.allow_multiple_selected) and str(
                    subvalue
                ) in value
                has_selected |= selected
                subgroup.append(
                    self.create_option(
                        name,
                        subvalue,
                        sublabel,
                        selected,
                        index,
                        subindex=subindex,
                        attrs=attrs,
                    )
                )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                if subindex is not None:
                    subindex += 1
        return groups

<<<<<<< HEAD
    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
        index = str(index) if subindex is None else "%s_%s" % (index, subindex)
        if attrs is None:
            attrs = {}
        option_attrs = self.build_attrs(self.attrs, attrs) if self.option_inherits_attrs else {}
        if selected:
            option_attrs.update(self.checked_attribute)
        if 'id' in option_attrs:
            option_attrs['id'] = self.id_for_label(option_attrs['id'], index)
        return {
            'name': name,
            'value': value,
            'label': label,
            'selected': selected,
            'index': index,
            'attrs': option_attrs,
            'type': self.input_type,
            'template_name': self.option_template_name,
            'wrap_label': True,
=======
    def create_option(
        self, name, value, label, selected, index, subindex=None, attrs=None
    ):
        index = str(index) if subindex is None else "%s_%s" % (index, subindex)
        option_attrs = (
            self.build_attrs(self.attrs, attrs) if self.option_inherits_attrs else {}
        )
        if selected:
            option_attrs.update(self.checked_attribute)
        if "id" in option_attrs:
            option_attrs["id"] = self.id_for_label(option_attrs["id"], index)
        return {
            "name": name,
            "value": value,
            "label": label,
            "selected": selected,
            "index": index,
            "attrs": option_attrs,
            "type": self.input_type,
            "template_name": self.option_template_name,
            "wrap_label": True,
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        }

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
<<<<<<< HEAD
        context['widget']['optgroups'] = self.optgroups(name, context['widget']['value'], attrs)
        return context

    def id_for_label(self, id_, index='0'):
=======
        context["widget"]["optgroups"] = self.optgroups(
            name, context["widget"]["value"], attrs
        )
        return context

    def id_for_label(self, id_, index="0"):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        """
        Use an incremented id for each option where the main widget
        references the zero index.
        """
        if id_ and self.add_id_index:
<<<<<<< HEAD
            id_ = '%s_%s' % (id_, index)
=======
            id_ = "%s_%s" % (id_, index)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return id_

    def value_from_datadict(self, data, files, name):
        getter = data.get
        if self.allow_multiple_selected:
            try:
                getter = data.getlist
            except AttributeError:
                pass
        return getter(name)

    def format_value(self, value):
        """Return selected values as a list."""
        if value is None and self.allow_multiple_selected:
            return []
        if not isinstance(value, (tuple, list)):
            value = [value]
<<<<<<< HEAD
        return [str(v) if v is not None else '' for v in value]


class Select(ChoiceWidget):
    input_type = 'select'
    template_name = 'django/forms/widgets/select.html'
    option_template_name = 'django/forms/widgets/select_option.html'
    add_id_index = False
    checked_attribute = {'selected': True}
=======
        return [str(v) if v is not None else "" for v in value]

    @property
    def choices(self):
        return self._choices

    @choices.setter
    def choices(self, value):
        self._choices = normalize_choices(value)


class Select(ChoiceWidget):
    input_type = "select"
    template_name = "django/forms/widgets/select.html"
    option_template_name = "django/forms/widgets/select_option.html"
    add_id_index = False
    checked_attribute = {"selected": True}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    option_inherits_attrs = False

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        if self.allow_multiple_selected:
<<<<<<< HEAD
            context['widget']['attrs']['multiple'] = True
=======
            context["widget"]["attrs"]["multiple"] = True
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return context

    @staticmethod
    def _choice_has_empty_value(choice):
        """Return True if the choice's value is empty string or None."""
        value, _ = choice
<<<<<<< HEAD
        return value is None or value == ''
=======
        return value is None or value == ""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def use_required_attribute(self, initial):
        """
        Don't render 'required' if the first <option> has a value, as that's
        invalid HTML.
        """
        use_required_attribute = super().use_required_attribute(initial)
        # 'required' is always okay for <select multiple>.
        if self.allow_multiple_selected:
            return use_required_attribute

        first_choice = next(iter(self.choices), None)
<<<<<<< HEAD
        return use_required_attribute and first_choice is not None and self._choice_has_empty_value(first_choice)
=======
        return (
            use_required_attribute
            and first_choice is not None
            and self._choice_has_empty_value(first_choice)
        )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class NullBooleanSelect(Select):
    """
    A Select Widget intended to be used with NullBooleanField.
    """
<<<<<<< HEAD
    def __init__(self, attrs=None):
        choices = (
            ('unknown', _('Unknown')),
            ('true', _('Yes')),
            ('false', _('No')),
=======

    def __init__(self, attrs=None):
        choices = (
            ("unknown", _("Unknown")),
            ("true", _("Yes")),
            ("false", _("No")),
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )
        super().__init__(attrs, choices)

    def format_value(self, value):
        try:
            return {
<<<<<<< HEAD
                True: 'true', False: 'false',
                'true': 'true', 'false': 'false',
                # For backwards compatibility with Django < 2.2.
                '2': 'true', '3': 'false',
            }[value]
        except KeyError:
            return 'unknown'
=======
                True: "true",
                False: "false",
                "true": "true",
                "false": "false",
                # For backwards compatibility with Django < 2.2.
                "2": "true",
                "3": "false",
            }[value]
        except KeyError:
            return "unknown"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def value_from_datadict(self, data, files, name):
        value = data.get(name)
        return {
            True: True,
<<<<<<< HEAD
            'True': True,
            'False': False,
            False: False,
            'true': True,
            'false': False,
            # For backwards compatibility with Django < 2.2.
            '2': True,
            '3': False,
=======
            "True": True,
            "False": False,
            False: False,
            "true": True,
            "false": False,
            # For backwards compatibility with Django < 2.2.
            "2": True,
            "3": False,
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        }.get(value)


class SelectMultiple(Select):
    allow_multiple_selected = True

    def value_from_datadict(self, data, files, name):
        try:
            getter = data.getlist
        except AttributeError:
            getter = data.get
        return getter(name)

    def value_omitted_from_data(self, data, files, name):
        # An unselected <select multiple> doesn't appear in POST data, so it's
        # never known if the value is actually omitted.
        return False


class RadioSelect(ChoiceWidget):
<<<<<<< HEAD
    input_type = 'radio'
    template_name = 'django/forms/widgets/radio.html'
    option_template_name = 'django/forms/widgets/radio_option.html'


class CheckboxSelectMultiple(ChoiceWidget):
    allow_multiple_selected = True
    input_type = 'checkbox'
    template_name = 'django/forms/widgets/checkbox_select.html'
    option_template_name = 'django/forms/widgets/checkbox_option.html'
=======
    input_type = "radio"
    template_name = "django/forms/widgets/radio.html"
    option_template_name = "django/forms/widgets/radio_option.html"
    use_fieldset = True

    def id_for_label(self, id_, index=None):
        """
        Don't include for="field_0" in <label> to improve accessibility when
        using a screen reader, in addition clicking such a label would toggle
        the first input.
        """
        if index is None:
            return ""
        return super().id_for_label(id_, index)


class CheckboxSelectMultiple(RadioSelect):
    allow_multiple_selected = True
    input_type = "checkbox"
    template_name = "django/forms/widgets/checkbox_select.html"
    option_template_name = "django/forms/widgets/checkbox_option.html"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def use_required_attribute(self, initial):
        # Don't use the 'required' attribute because browser validation would
        # require all checkboxes to be checked instead of at least one.
        return False

    def value_omitted_from_data(self, data, files, name):
        # HTML checkboxes don't appear in POST data if not checked, so it's
        # never known if the value is actually omitted.
        return False

<<<<<<< HEAD
    def id_for_label(self, id_, index=None):
        """
        Don't include for="field_0" in <label> because clicking such a label
        would toggle the first checkbox.
        """
        if index is None:
            return ''
        return super().id_for_label(id_, index)

=======
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

class MultiWidget(Widget):
    """
    A widget that is composed of multiple widgets.

    In addition to the values added by Widget.get_context(), this widget
    adds a list of subwidgets to the context as widget['subwidgets'].
    These can be looped over and rendered like normal widgets.

    You'll probably want to use this class with MultiValueField.
    """
<<<<<<< HEAD
    template_name = 'django/forms/widgets/multiwidget.html'

    def __init__(self, widgets, attrs=None):
        if isinstance(widgets, dict):
            self.widgets_names = [
                ('_%s' % name) if name else '' for name in widgets
            ]
            widgets = widgets.values()
        else:
            self.widgets_names = ['_%s' % i for i in range(len(widgets))]
=======

    template_name = "django/forms/widgets/multiwidget.html"
    use_fieldset = True

    def __init__(self, widgets, attrs=None):
        if isinstance(widgets, dict):
            self.widgets_names = [("_%s" % name) if name else "" for name in widgets]
            widgets = widgets.values()
        else:
            self.widgets_names = ["_%s" % i for i in range(len(widgets))]
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        self.widgets = [w() if isinstance(w, type) else w for w in widgets]
        super().__init__(attrs)

    @property
    def is_hidden(self):
        return all(w.is_hidden for w in self.widgets)

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        if self.is_localized:
            for widget in self.widgets:
                widget.is_localized = self.is_localized
<<<<<<< HEAD
        # value is a list of values, each corresponding to a widget
        # in self.widgets.
        if not isinstance(value, list):
            value = self.decompress(value)

        final_attrs = context['widget']['attrs']
        input_type = final_attrs.pop('type', None)
        id_ = final_attrs.get('id')
        subwidgets = []
        for i, (widget_name, widget) in enumerate(zip(self.widgets_names, self.widgets)):
=======
        # value is a list/tuple of values, each corresponding to a widget
        # in self.widgets.
        if not isinstance(value, (list, tuple)):
            value = self.decompress(value)

        final_attrs = context["widget"]["attrs"]
        input_type = final_attrs.pop("type", None)
        id_ = final_attrs.get("id")
        subwidgets = []
        for i, (widget_name, widget) in enumerate(
            zip(self.widgets_names, self.widgets)
        ):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            if input_type is not None:
                widget.input_type = input_type
            widget_name = name + widget_name
            try:
                widget_value = value[i]
            except IndexError:
                widget_value = None
            if id_:
                widget_attrs = final_attrs.copy()
<<<<<<< HEAD
                widget_attrs['id'] = '%s_%s' % (id_, i)
            else:
                widget_attrs = final_attrs
            subwidgets.append(widget.get_context(widget_name, widget_value, widget_attrs)['widget'])
        context['widget']['subwidgets'] = subwidgets
        return context

    def id_for_label(self, id_):
        if id_:
            id_ += '_0'
        return id_
=======
                widget_attrs["id"] = "%s_%s" % (id_, i)
            else:
                widget_attrs = final_attrs
            subwidgets.append(
                widget.get_context(widget_name, widget_value, widget_attrs)["widget"]
            )
        context["widget"]["subwidgets"] = subwidgets
        return context

    def id_for_label(self, id_):
        return ""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def value_from_datadict(self, data, files, name):
        return [
            widget.value_from_datadict(data, files, name + widget_name)
            for widget_name, widget in zip(self.widgets_names, self.widgets)
        ]

    def value_omitted_from_data(self, data, files, name):
        return all(
            widget.value_omitted_from_data(data, files, name + widget_name)
            for widget_name, widget in zip(self.widgets_names, self.widgets)
        )

    def decompress(self, value):
        """
        Return a list of decompressed values for the given compressed value.
        The given value can be assumed to be valid, but not necessarily
        non-empty.
        """
<<<<<<< HEAD
        raise NotImplementedError('Subclasses must implement this method.')
=======
        raise NotImplementedError("Subclasses must implement this method.")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _get_media(self):
        """
        Media for a multiwidget is the combination of all media of the
        subwidgets.
        """
        media = Media()
        for w in self.widgets:
<<<<<<< HEAD
            media = media + w.media
        return media
=======
            media += w.media
        return media

>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    media = property(_get_media)

    def __deepcopy__(self, memo):
        obj = super().__deepcopy__(memo)
        obj.widgets = copy.deepcopy(self.widgets)
        return obj

    @property
    def needs_multipart_form(self):
        return any(w.needs_multipart_form for w in self.widgets)


class SplitDateTimeWidget(MultiWidget):
    """
    A widget that splits datetime input into two <input type="text"> boxes.
    """
<<<<<<< HEAD
    supports_microseconds = False
    template_name = 'django/forms/widgets/splitdatetime.html'

    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
=======

    supports_microseconds = False
    template_name = "django/forms/widgets/splitdatetime.html"

    def __init__(
        self,
        attrs=None,
        date_format=None,
        time_format=None,
        date_attrs=None,
        time_attrs=None,
    ):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        widgets = (
            DateInput(
                attrs=attrs if date_attrs is None else date_attrs,
                format=date_format,
            ),
            TimeInput(
                attrs=attrs if time_attrs is None else time_attrs,
                format=time_format,
            ),
        )
        super().__init__(widgets)

    def decompress(self, value):
        if value:
            value = to_current_timezone(value)
            return [value.date(), value.time()]
        return [None, None]


class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    """
    A widget that splits datetime input into two <input type="hidden"> inputs.
    """
<<<<<<< HEAD
    template_name = 'django/forms/widgets/splithiddendatetime.html'

    def __init__(self, attrs=None, date_format=None, time_format=None, date_attrs=None, time_attrs=None):
        super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)
        for widget in self.widgets:
            widget.input_type = 'hidden'
=======

    template_name = "django/forms/widgets/splithiddendatetime.html"

    def __init__(
        self,
        attrs=None,
        date_format=None,
        time_format=None,
        date_attrs=None,
        time_attrs=None,
    ):
        super().__init__(attrs, date_format, time_format, date_attrs, time_attrs)
        for widget in self.widgets:
            widget.input_type = "hidden"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class SelectDateWidget(Widget):
    """
    A widget that splits date input into three <select> boxes.

    This also serves as an example of a Widget that has more than one HTML
    element and hence implements value_from_datadict.
    """
<<<<<<< HEAD
    none_value = ('', '---')
    month_field = '%s_month'
    day_field = '%s_day'
    year_field = '%s_year'
    template_name = 'django/forms/widgets/select_date.html'
    input_type = 'select'
    select_widget = Select
    date_re = _lazy_re_compile(r'(\d{4}|0)-(\d\d?)-(\d\d?)$')
=======

    none_value = ("", "---")
    month_field = "%s_month"
    day_field = "%s_day"
    year_field = "%s_year"
    template_name = "django/forms/widgets/select_date.html"
    input_type = "select"
    select_widget = Select
    date_re = _lazy_re_compile(r"(\d{4}|0)-(\d\d?)-(\d\d?)$")
    use_fieldset = True
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, attrs=None, years=None, months=None, empty_label=None):
        self.attrs = attrs or {}

        # Optional list or tuple of years to use in the "year" select box.
        if years:
            self.years = years
        else:
            this_year = datetime.date.today().year
            self.years = range(this_year, this_year + 10)

        # Optional dict of months to use in the "month" select box.
        if months:
            self.months = months
        else:
            self.months = MONTHS

        # Optional string, list, or tuple to use as empty_label.
        if isinstance(empty_label, (list, tuple)):
            if not len(empty_label) == 3:
<<<<<<< HEAD
                raise ValueError('empty_label list/tuple must have 3 elements.')

            self.year_none_value = ('', empty_label[0])
            self.month_none_value = ('', empty_label[1])
            self.day_none_value = ('', empty_label[2])
        else:
            if empty_label is not None:
                self.none_value = ('', empty_label)
=======
                raise ValueError("empty_label list/tuple must have 3 elements.")

            self.year_none_value = ("", empty_label[0])
            self.month_none_value = ("", empty_label[1])
            self.day_none_value = ("", empty_label[2])
        else:
            if empty_label is not None:
                self.none_value = ("", empty_label)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

            self.year_none_value = self.none_value
            self.month_none_value = self.none_value
            self.day_none_value = self.none_value

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        date_context = {}
        year_choices = [(i, str(i)) for i in self.years]
        if not self.is_required:
            year_choices.insert(0, self.year_none_value)
        year_name = self.year_field % name
<<<<<<< HEAD
        date_context['year'] = self.select_widget(attrs, choices=year_choices).get_context(
            name=year_name,
            value=context['widget']['value']['year'],
            attrs={**context['widget']['attrs'], 'id': 'id_%s' % year_name},
=======
        date_context["year"] = self.select_widget(
            attrs, choices=year_choices
        ).get_context(
            name=year_name,
            value=context["widget"]["value"]["year"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % year_name},
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )
        month_choices = list(self.months.items())
        if not self.is_required:
            month_choices.insert(0, self.month_none_value)
        month_name = self.month_field % name
<<<<<<< HEAD
        date_context['month'] = self.select_widget(attrs, choices=month_choices).get_context(
            name=month_name,
            value=context['widget']['value']['month'],
            attrs={**context['widget']['attrs'], 'id': 'id_%s' % month_name},
=======
        date_context["month"] = self.select_widget(
            attrs, choices=month_choices
        ).get_context(
            name=month_name,
            value=context["widget"]["value"]["month"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % month_name},
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )
        day_choices = [(i, i) for i in range(1, 32)]
        if not self.is_required:
            day_choices.insert(0, self.day_none_value)
        day_name = self.day_field % name
<<<<<<< HEAD
        date_context['day'] = self.select_widget(attrs, choices=day_choices,).get_context(
            name=day_name,
            value=context['widget']['value']['day'],
            attrs={**context['widget']['attrs'], 'id': 'id_%s' % day_name},
        )
        subwidgets = []
        for field in self._parse_date_fmt():
            subwidgets.append(date_context[field]['widget'])
        context['widget']['subwidgets'] = subwidgets
=======
        date_context["day"] = self.select_widget(
            attrs,
            choices=day_choices,
        ).get_context(
            name=day_name,
            value=context["widget"]["value"]["day"],
            attrs={**context["widget"]["attrs"], "id": "id_%s" % day_name},
        )
        subwidgets = []
        for field in self._parse_date_fmt():
            subwidgets.append(date_context[field]["widget"])
        context["widget"]["subwidgets"] = subwidgets
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return context

    def format_value(self, value):
        """
        Return a dict containing the year, month, and day of the current value.
        Use dict instead of a datetime to allow invalid dates such as February
        31 to display correctly.
        """
        year, month, day = None, None, None
        if isinstance(value, (datetime.date, datetime.datetime)):
            year, month, day = value.year, value.month, value.day
        elif isinstance(value, str):
            match = self.date_re.match(value)
            if match:
                # Convert any zeros in the date to empty strings to match the
                # empty option value.
<<<<<<< HEAD
                year, month, day = [int(val) or '' for val in match.groups()]
            else:
                input_format = get_format('DATE_INPUT_FORMATS')[0]
=======
                year, month, day = [int(val) or "" for val in match.groups()]
            else:
                input_format = get_format("DATE_INPUT_FORMATS")[0]
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                try:
                    d = datetime.datetime.strptime(value, input_format)
                except ValueError:
                    pass
                else:
                    year, month, day = d.year, d.month, d.day
<<<<<<< HEAD
        return {'year': year, 'month': month, 'day': day}

    @staticmethod
    def _parse_date_fmt():
        fmt = get_format('DATE_FORMAT')
=======
        return {"year": year, "month": month, "day": day}

    @staticmethod
    def _parse_date_fmt():
        fmt = get_format("DATE_FORMAT")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        escaped = False
        for char in fmt:
            if escaped:
                escaped = False
<<<<<<< HEAD
            elif char == '\\':
                escaped = True
            elif char in 'Yy':
                yield 'year'
            elif char in 'bEFMmNn':
                yield 'month'
            elif char in 'dj':
                yield 'day'

    def id_for_label(self, id_):
        for first_select in self._parse_date_fmt():
            return '%s_%s' % (id_, first_select)
        return '%s_month' % id_
=======
            elif char == "\\":
                escaped = True
            elif char in "Yy":
                yield "year"
            elif char in "bEFMmNn":
                yield "month"
            elif char in "dj":
                yield "day"

    def id_for_label(self, id_):
        for first_select in self._parse_date_fmt():
            return "%s_%s" % (id_, first_select)
        return "%s_month" % id_
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def value_from_datadict(self, data, files, name):
        y = data.get(self.year_field % name)
        m = data.get(self.month_field % name)
        d = data.get(self.day_field % name)
<<<<<<< HEAD
        if y == m == d == '':
            return None
        if y is not None and m is not None and d is not None:
            input_format = get_format('DATE_INPUT_FORMATS')[0]
=======
        if y == m == d == "":
            return None
        if y is not None and m is not None and d is not None:
            input_format = get_format("DATE_INPUT_FORMATS")[0]
            input_format = formats.sanitize_strftime_format(input_format)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            try:
                date_value = datetime.date(int(y), int(m), int(d))
            except ValueError:
                # Return pseudo-ISO dates with zeros for any unselected values,
                # e.g. '2017-0-23'.
<<<<<<< HEAD
                return '%s-%s-%s' % (y or 0, m or 0, d or 0)
            date_value = datetime_safe.new_date(date_value)
=======
                return "%s-%s-%s" % (y or 0, m or 0, d or 0)
            except OverflowError:
                return "0-0-0"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            return date_value.strftime(input_format)
        return data.get(name)

    def value_omitted_from_data(self, data, files, name):
        return not any(
<<<<<<< HEAD
            ('{}_{}'.format(name, interval) in data)
            for interval in ('year', 'month', 'day')
=======
            ("{}_{}".format(name, interval) in data)
            for interval in ("year", "month", "day")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )
