import logging
import os
import re
from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int
from ctypes.util import find_library

from django.contrib.gis.gdal.error import GDALException
from django.core.exceptions import ImproperlyConfigured

<<<<<<< HEAD
logger = logging.getLogger('django.contrib.gis')
=======
logger = logging.getLogger("django.contrib.gis")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

# Custom library path set?
try:
    from django.conf import settings
<<<<<<< HEAD
=======

>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    lib_path = settings.GDAL_LIBRARY_PATH
except (AttributeError, ImportError, ImproperlyConfigured, OSError):
    lib_path = None

if lib_path:
    lib_names = None
<<<<<<< HEAD
elif os.name == 'nt':
    # Windows NT shared libraries
    lib_names = [
        'gdal302', 'gdal301', 'gdal300',
        'gdal204', 'gdal203', 'gdal202', 'gdal201', 'gdal20',
    ]
elif os.name == 'posix':
    # *NIX library names.
    lib_names = [
        'gdal', 'GDAL',
        'gdal3.2.0', 'gdal3.1.0', 'gdal3.0.0',
        'gdal2.4.0', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0',
=======
elif os.name == "nt":
    # Windows NT shared libraries
    lib_names = [
        "gdal307",
        "gdal306",
        "gdal305",
        "gdal304",
        "gdal303",
        "gdal302",
        "gdal301",
        "gdal300",
        "gdal204",
    ]
elif os.name == "posix":
    # *NIX library names.
    lib_names = [
        "gdal",
        "GDAL",
        "gdal3.7.0",
        "gdal3.6.0",
        "gdal3.5.0",
        "gdal3.4.0",
        "gdal3.3.0",
        "gdal3.2.0",
        "gdal3.1.0",
        "gdal3.0.0",
        "gdal2.4.0",
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    ]
else:
    raise ImproperlyConfigured('GDAL is unsupported on OS "%s".' % os.name)

# Using the ctypes `find_library` utility  to find the
# path to the GDAL library from the list of library names.
if lib_names:
    for lib_name in lib_names:
        lib_path = find_library(lib_name)
        if lib_path is not None:
            break

if lib_path is None:
    raise ImproperlyConfigured(
        'Could not find the GDAL library (tried "%s"). Is GDAL installed? '
<<<<<<< HEAD
        'If it is, try setting GDAL_LIBRARY_PATH in your settings.'
=======
        "If it is, try setting GDAL_LIBRARY_PATH in your settings."
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        % '", "'.join(lib_names)
    )

# This loads the GDAL/OGR C library
lgdal = CDLL(lib_path)

# On Windows, the GDAL binaries have some OSR routines exported with
# STDCALL, while others are not.  Thus, the library will also need to
# be loaded up as WinDLL for said OSR functions that require the
# different calling convention.
<<<<<<< HEAD
if os.name == 'nt':
    from ctypes import WinDLL
=======
if os.name == "nt":
    from ctypes import WinDLL

>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    lwingdal = WinDLL(lib_path)


def std_call(func):
    """
    Return the correct STDCALL function for certain OSR routines on Win32
    platforms.
    """
<<<<<<< HEAD
    if os.name == 'nt':
=======
    if os.name == "nt":
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return lwingdal[func]
    else:
        return lgdal[func]


# #### Version-information functions. ####

# Return GDAL library version information with the given key.
<<<<<<< HEAD
_version_info = std_call('GDALVersionInfo')
=======
_version_info = std_call("GDALVersionInfo")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
_version_info.argtypes = [c_char_p]
_version_info.restype = c_char_p


def gdal_version():
    "Return only the GDAL version number information."
<<<<<<< HEAD
    return _version_info(b'RELEASE_NAME')
=======
    return _version_info(b"RELEASE_NAME")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


def gdal_full_version():
    "Return the full GDAL version information."
<<<<<<< HEAD
    return _version_info(b'')
=======
    return _version_info(b"")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


def gdal_version_info():
    ver = gdal_version()
<<<<<<< HEAD
    m = re.match(br'^(?P<major>\d+)\.(?P<minor>\d+)(?:\.(?P<subminor>\d+))?', ver)
=======
    m = re.match(rb"^(?P<major>\d+)\.(?P<minor>\d+)(?:\.(?P<subminor>\d+))?", ver)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    if not m:
        raise GDALException('Could not parse GDAL version string "%s"' % ver)
    major, minor, subminor = m.groups()
    return (int(major), int(minor), subminor and int(subminor))


GDAL_VERSION = gdal_version_info()

# Set library error handling so as errors are logged
CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)


def err_handler(error_class, error_number, message):
<<<<<<< HEAD
    logger.error('GDAL_ERROR %d: %s', error_number, message)
=======
    logger.error("GDAL_ERROR %d: %s", error_number, message)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


err_handler = CPLErrorHandler(err_handler)


def function(name, args, restype):
    func = std_call(name)
    func.argtypes = args
    func.restype = restype
    return func


<<<<<<< HEAD
set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)
=======
set_error_handler = function("CPLSetErrorHandler", [CPLErrorHandler], CPLErrorHandler)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
set_error_handler(err_handler)
