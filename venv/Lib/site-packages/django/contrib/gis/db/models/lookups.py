from django.contrib.gis.db.models.fields import BaseSpatialField
from django.contrib.gis.measure import Distance
from django.db import NotSupportedError
from django.db.models import Expression, Lookup, Transform
from django.db.models.sql.query import Query
from django.utils.regex_helper import _lazy_re_compile


class RasterBandTransform(Transform):
    def as_sql(self, compiler, connection):
        return compiler.compile(self.lhs)


class GISLookup(Lookup):
    sql_template = None
    transform_func = None
    distance = False
    band_rhs = None
    band_lhs = None

    def __init__(self, lhs, rhs):
        rhs, *self.rhs_params = rhs if isinstance(rhs, (list, tuple)) else [rhs]
        super().__init__(lhs, rhs)
        self.template_params = {}
        self.process_rhs_params()

    def process_rhs_params(self):
        if self.rhs_params:
            # Check if a band index was passed in the query argument.
<<<<<<< HEAD
            if len(self.rhs_params) == (2 if self.lookup_name == 'relate' else 1):
                self.process_band_indices()
            elif len(self.rhs_params) > 1:
                raise ValueError('Tuple too long for lookup %s.' % self.lookup_name)
=======
            if len(self.rhs_params) == (2 if self.lookup_name == "relate" else 1):
                self.process_band_indices()
            elif len(self.rhs_params) > 1:
                raise ValueError("Tuple too long for lookup %s." % self.lookup_name)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        elif isinstance(self.lhs, RasterBandTransform):
            self.process_band_indices(only_lhs=True)

    def process_band_indices(self, only_lhs=False):
        """
        Extract the lhs band index from the band transform class and the rhs
        band index from the input tuple.
        """
        # PostGIS band indices are 1-based, so the band index needs to be
        # increased to be consistent with the GDALRaster band indices.
        if only_lhs:
            self.band_rhs = 1
            self.band_lhs = self.lhs.band_index + 1
            return

        if isinstance(self.lhs, RasterBandTransform):
            self.band_lhs = self.lhs.band_index + 1
        else:
            self.band_lhs = 1

        self.band_rhs, *self.rhs_params = self.rhs_params

    def get_db_prep_lookup(self, value, connection):
        # get_db_prep_lookup is called by process_rhs from super class
<<<<<<< HEAD
        return ('%s', [connection.ops.Adapter(value)])
=======
        return ("%s", [connection.ops.Adapter(value)])
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def process_rhs(self, compiler, connection):
        if isinstance(self.rhs, Query):
            # If rhs is some Query, don't touch it.
            return super().process_rhs(compiler, connection)
        if isinstance(self.rhs, Expression):
            self.rhs = self.rhs.resolve_expression(compiler.query)
        rhs, rhs_params = super().process_rhs(compiler, connection)
<<<<<<< HEAD
        placeholder = connection.ops.get_geom_placeholder(self.lhs.output_field, self.rhs, compiler)
=======
        placeholder = connection.ops.get_geom_placeholder(
            self.lhs.output_field, self.rhs, compiler
        )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return placeholder % rhs, rhs_params

    def get_rhs_op(self, connection, rhs):
        # Unlike BuiltinLookup, the GIS get_rhs_op() implementation should return
        # an object (SpatialOperator) with an as_sql() method to allow for more
        # complex computations (where the lhs part can be mixed in).
        return connection.ops.gis_operators[self.lookup_name]

    def as_sql(self, compiler, connection):
        lhs_sql, lhs_params = self.process_lhs(compiler, connection)
        rhs_sql, rhs_params = self.process_rhs(compiler, connection)
        sql_params = (*lhs_params, *rhs_params)

<<<<<<< HEAD
        template_params = {'lhs': lhs_sql, 'rhs': rhs_sql, 'value': '%s', **self.template_params}
=======
        template_params = {
            "lhs": lhs_sql,
            "rhs": rhs_sql,
            "value": "%s",
            **self.template_params,
        }
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        rhs_op = self.get_rhs_op(connection, rhs_sql)
        return rhs_op.as_sql(connection, self, template_params, sql_params)


# ------------------
# Geometry operators
# ------------------

<<<<<<< HEAD
=======

>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
@BaseSpatialField.register_lookup
class OverlapsLeftLookup(GISLookup):
    """
    The overlaps_left operator returns true if A's bounding box overlaps or is to the
    left of B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'overlaps_left'
=======

    lookup_name = "overlaps_left"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class OverlapsRightLookup(GISLookup):
    """
    The 'overlaps_right' operator returns true if A's bounding box overlaps or is to the
    right of B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'overlaps_right'
=======

    lookup_name = "overlaps_right"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class OverlapsBelowLookup(GISLookup):
    """
    The 'overlaps_below' operator returns true if A's bounding box overlaps or is below
    B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'overlaps_below'
=======

    lookup_name = "overlaps_below"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class OverlapsAboveLookup(GISLookup):
    """
    The 'overlaps_above' operator returns true if A's bounding box overlaps or is above
    B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'overlaps_above'
=======

    lookup_name = "overlaps_above"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class LeftLookup(GISLookup):
    """
    The 'left' operator returns true if A's bounding box is strictly to the left
    of B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'left'
=======

    lookup_name = "left"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class RightLookup(GISLookup):
    """
    The 'right' operator returns true if A's bounding box is strictly to the right
    of B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'right'
=======

    lookup_name = "right"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class StrictlyBelowLookup(GISLookup):
    """
    The 'strictly_below' operator returns true if A's bounding box is strictly below B's
    bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'strictly_below'
=======

    lookup_name = "strictly_below"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class StrictlyAboveLookup(GISLookup):
    """
    The 'strictly_above' operator returns true if A's bounding box is strictly above B's
    bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'strictly_above'
=======

    lookup_name = "strictly_above"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class SameAsLookup(GISLookup):
    """
    The "~=" operator is the "same as" operator. It tests actual geometric
    equality of two features. So if A and B are the same feature,
    vertex-by-vertex, the operator returns true.
    """
<<<<<<< HEAD
    lookup_name = 'same_as'


BaseSpatialField.register_lookup(SameAsLookup, 'exact')
=======

    lookup_name = "same_as"


BaseSpatialField.register_lookup(SameAsLookup, "exact")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class BBContainsLookup(GISLookup):
    """
    The 'bbcontains' operator returns true if A's bounding box completely contains
    by B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'bbcontains'
=======

    lookup_name = "bbcontains"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class BBOverlapsLookup(GISLookup):
    """
<<<<<<< HEAD
    The 'bboverlaps' operator returns true if A's bounding box overlaps B's bounding box.
    """
    lookup_name = 'bboverlaps'
=======
    The 'bboverlaps' operator returns true if A's bounding box overlaps B's
    bounding box.
    """

    lookup_name = "bboverlaps"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class ContainedLookup(GISLookup):
    """
    The 'contained' operator returns true if A's bounding box is completely contained
    by B's bounding box.
    """
<<<<<<< HEAD
    lookup_name = 'contained'
=======

    lookup_name = "contained"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


# ------------------
# Geometry functions
# ------------------

<<<<<<< HEAD
@BaseSpatialField.register_lookup
class ContainsLookup(GISLookup):
    lookup_name = 'contains'
=======

@BaseSpatialField.register_lookup
class ContainsLookup(GISLookup):
    lookup_name = "contains"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class ContainsProperlyLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'contains_properly'
=======
    lookup_name = "contains_properly"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class CoveredByLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'coveredby'
=======
    lookup_name = "coveredby"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class CoversLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'covers'
=======
    lookup_name = "covers"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class CrossesLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'crosses'
=======
    lookup_name = "crosses"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class DisjointLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'disjoint'
=======
    lookup_name = "disjoint"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class EqualsLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'equals'
=======
    lookup_name = "equals"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class IntersectsLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'intersects'
=======
    lookup_name = "intersects"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class OverlapsLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'overlaps'
=======
    lookup_name = "overlaps"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class RelateLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'relate'
    sql_template = '%(func)s(%(lhs)s, %(rhs)s, %%s)'
    pattern_regex = _lazy_re_compile(r'^[012TF\*]{9}$')
=======
    lookup_name = "relate"
    sql_template = "%(func)s(%(lhs)s, %(rhs)s, %%s)"
    pattern_regex = _lazy_re_compile(r"^[012TF*]{9}$")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def process_rhs(self, compiler, connection):
        # Check the pattern argument
        pattern = self.rhs_params[0]
        backend_op = connection.ops.gis_operators[self.lookup_name]
<<<<<<< HEAD
        if hasattr(backend_op, 'check_relate_argument'):
=======
        if hasattr(backend_op, "check_relate_argument"):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            backend_op.check_relate_argument(pattern)
        elif not isinstance(pattern, str) or not self.pattern_regex.match(pattern):
            raise ValueError('Invalid intersection matrix pattern "%s".' % pattern)
        sql, params = super().process_rhs(compiler, connection)
        return sql, params + [pattern]


@BaseSpatialField.register_lookup
class TouchesLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'touches'
=======
    lookup_name = "touches"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class WithinLookup(GISLookup):
<<<<<<< HEAD
    lookup_name = 'within'
=======
    lookup_name = "within"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class DistanceLookupBase(GISLookup):
    distance = True
<<<<<<< HEAD
    sql_template = '%(func)s(%(lhs)s, %(rhs)s) %(op)s %(value)s'

    def process_rhs_params(self):
        if not 1 <= len(self.rhs_params) <= 3:
            raise ValueError("2, 3, or 4-element tuple required for '%s' lookup." % self.lookup_name)
        elif len(self.rhs_params) == 3 and self.rhs_params[2] != 'spheroid':
            raise ValueError("For 4-element tuples the last argument must be the 'spheroid' directive.")

        # Check if the second parameter is a band index.
        if len(self.rhs_params) > 1 and self.rhs_params[1] != 'spheroid':
=======
    sql_template = "%(func)s(%(lhs)s, %(rhs)s) %(op)s %(value)s"

    def process_rhs_params(self):
        if not 1 <= len(self.rhs_params) <= 3:
            raise ValueError(
                "2, 3, or 4-element tuple required for '%s' lookup." % self.lookup_name
            )
        elif len(self.rhs_params) == 3 and self.rhs_params[2] != "spheroid":
            raise ValueError(
                "For 4-element tuples the last argument must be the 'spheroid' "
                "directive."
            )

        # Check if the second parameter is a band index.
        if len(self.rhs_params) > 1 and self.rhs_params[1] != "spheroid":
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            self.process_band_indices()

    def process_distance(self, compiler, connection):
        dist_param = self.rhs_params[0]
        return (
            compiler.compile(dist_param.resolve_expression(compiler.query))
<<<<<<< HEAD
            if hasattr(dist_param, 'resolve_expression') else
            ('%s', connection.ops.get_distance(self.lhs.output_field, self.rhs_params, self.lookup_name))
=======
            if hasattr(dist_param, "resolve_expression")
            else (
                "%s",
                connection.ops.get_distance(
                    self.lhs.output_field, self.rhs_params, self.lookup_name
                ),
            )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        )


@BaseSpatialField.register_lookup
class DWithinLookup(DistanceLookupBase):
<<<<<<< HEAD
    lookup_name = 'dwithin'
    sql_template = '%(func)s(%(lhs)s, %(rhs)s, %(value)s)'
=======
    lookup_name = "dwithin"
    sql_template = "%(func)s(%(lhs)s, %(rhs)s, %(value)s)"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def process_distance(self, compiler, connection):
        dist_param = self.rhs_params[0]
        if (
<<<<<<< HEAD
            not connection.features.supports_dwithin_distance_expr and
            hasattr(dist_param, 'resolve_expression') and
            not isinstance(dist_param, Distance)
        ):
            raise NotSupportedError(
                'This backend does not support expressions for specifying '
                'distance in the dwithin lookup.'
=======
            not connection.features.supports_dwithin_distance_expr
            and hasattr(dist_param, "resolve_expression")
            and not isinstance(dist_param, Distance)
        ):
            raise NotSupportedError(
                "This backend does not support expressions for specifying "
                "distance in the dwithin lookup."
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            )
        return super().process_distance(compiler, connection)

    def process_rhs(self, compiler, connection):
        dist_sql, dist_params = self.process_distance(compiler, connection)
<<<<<<< HEAD
        self.template_params['value'] = dist_sql
=======
        self.template_params["value"] = dist_sql
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        rhs_sql, params = super().process_rhs(compiler, connection)
        return rhs_sql, params + dist_params


class DistanceLookupFromFunction(DistanceLookupBase):
    def as_sql(self, compiler, connection):
<<<<<<< HEAD
        spheroid = (len(self.rhs_params) == 2 and self.rhs_params[-1] == 'spheroid') or None
        distance_expr = connection.ops.distance_expr_for_lookup(self.lhs, self.rhs, spheroid=spheroid)
        sql, params = compiler.compile(distance_expr.resolve_expression(compiler.query))
        dist_sql, dist_params = self.process_distance(compiler, connection)
        return (
            '%(func)s %(op)s %(dist)s' % {'func': sql, 'op': self.op, 'dist': dist_sql},
=======
        spheroid = (
            len(self.rhs_params) == 2 and self.rhs_params[-1] == "spheroid"
        ) or None
        distance_expr = connection.ops.distance_expr_for_lookup(
            self.lhs, self.rhs, spheroid=spheroid
        )
        sql, params = compiler.compile(distance_expr.resolve_expression(compiler.query))
        dist_sql, dist_params = self.process_distance(compiler, connection)
        return (
            "%(func)s %(op)s %(dist)s" % {"func": sql, "op": self.op, "dist": dist_sql},
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            params + dist_params,
        )


@BaseSpatialField.register_lookup
class DistanceGTLookup(DistanceLookupFromFunction):
<<<<<<< HEAD
    lookup_name = 'distance_gt'
    op = '>'
=======
    lookup_name = "distance_gt"
    op = ">"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class DistanceGTELookup(DistanceLookupFromFunction):
<<<<<<< HEAD
    lookup_name = 'distance_gte'
    op = '>='
=======
    lookup_name = "distance_gte"
    op = ">="
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class DistanceLTLookup(DistanceLookupFromFunction):
<<<<<<< HEAD
    lookup_name = 'distance_lt'
    op = '<'
=======
    lookup_name = "distance_lt"
    op = "<"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


@BaseSpatialField.register_lookup
class DistanceLTELookup(DistanceLookupFromFunction):
<<<<<<< HEAD
    lookup_name = 'distance_lte'
    op = '<='
=======
    lookup_name = "distance_lte"
    op = "<="
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
