from django.db import NotSupportedError
from django.db.models import Func, Index
from django.utils.functional import cached_property

__all__ = [
<<<<<<< HEAD
    'BloomIndex', 'BrinIndex', 'BTreeIndex', 'GinIndex', 'GistIndex',
    'HashIndex', 'SpGistIndex',
=======
    "BloomIndex",
    "BrinIndex",
    "BTreeIndex",
    "GinIndex",
    "GistIndex",
    "HashIndex",
    "SpGistIndex",
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
]


class PostgresIndex(Index):
<<<<<<< HEAD

=======
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    @cached_property
    def max_name_length(self):
        # Allow an index name longer than 30 characters when the suffix is
        # longer than the usual 3 character limit. The 30 character limit for
        # cross-database compatibility isn't applicable to PostgreSQL-specific
        # indexes.
        return Index.max_name_length - len(Index.suffix) + len(self.suffix)

<<<<<<< HEAD
    def create_sql(self, model, schema_editor, using='', **kwargs):
        self.check_supported(schema_editor)
        statement = super().create_sql(model, schema_editor, using=' USING %s' % self.suffix, **kwargs)
        with_params = self.get_with_params()
        if with_params:
            statement.parts['extra'] = 'WITH (%s) %s' % (
                ', '.join(with_params),
                statement.parts['extra'],
=======
    def create_sql(self, model, schema_editor, using="", **kwargs):
        self.check_supported(schema_editor)
        statement = super().create_sql(
            model, schema_editor, using=" USING %s" % (using or self.suffix), **kwargs
        )
        with_params = self.get_with_params()
        if with_params:
            statement.parts["extra"] = " WITH (%s)%s" % (
                ", ".join(with_params),
                statement.parts["extra"],
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            )
        return statement

    def check_supported(self, schema_editor):
        pass

    def get_with_params(self):
        return []


class BloomIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'bloom'
=======
    suffix = "bloom"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *expressions, length=None, columns=(), **kwargs):
        super().__init__(*expressions, **kwargs)
        if len(self.fields) > 32:
<<<<<<< HEAD
            raise ValueError('Bloom indexes support a maximum of 32 fields.')
        if not isinstance(columns, (list, tuple)):
            raise ValueError('BloomIndex.columns must be a list or tuple.')
        if len(columns) > len(self.fields):
            raise ValueError(
                'BloomIndex.columns cannot have more values than fields.'
            )
        if not all(0 < col <= 4095 for col in columns):
            raise ValueError(
                'BloomIndex.columns must contain integers from 1 to 4095.',
            )
        if length is not None and not 0 < length <= 4096:
            raise ValueError(
                'BloomIndex.length must be None or an integer from 1 to 4096.',
=======
            raise ValueError("Bloom indexes support a maximum of 32 fields.")
        if not isinstance(columns, (list, tuple)):
            raise ValueError("BloomIndex.columns must be a list or tuple.")
        if len(columns) > len(self.fields):
            raise ValueError("BloomIndex.columns cannot have more values than fields.")
        if not all(0 < col <= 4095 for col in columns):
            raise ValueError(
                "BloomIndex.columns must contain integers from 1 to 4095.",
            )
        if length is not None and not 0 < length <= 4096:
            raise ValueError(
                "BloomIndex.length must be None or an integer from 1 to 4096.",
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            )
        self.length = length
        self.columns = columns

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.length is not None:
<<<<<<< HEAD
            kwargs['length'] = self.length
        if self.columns:
            kwargs['columns'] = self.columns
=======
            kwargs["length"] = self.length
        if self.columns:
            kwargs["columns"] = self.columns
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.length is not None:
<<<<<<< HEAD
            with_params.append('length = %d' % self.length)
        if self.columns:
            with_params.extend(
                'col%d = %d' % (i, v)
                for i, v in enumerate(self.columns, start=1)
=======
            with_params.append("length = %d" % self.length)
        if self.columns:
            with_params.extend(
                "col%d = %d" % (i, v) for i, v in enumerate(self.columns, start=1)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            )
        return with_params


class BrinIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'brin'

    def __init__(self, *expressions, autosummarize=None, pages_per_range=None, **kwargs):
        if pages_per_range is not None and pages_per_range <= 0:
            raise ValueError('pages_per_range must be None or a positive integer')
=======
    suffix = "brin"

    def __init__(
        self, *expressions, autosummarize=None, pages_per_range=None, **kwargs
    ):
        if pages_per_range is not None and pages_per_range <= 0:
            raise ValueError("pages_per_range must be None or a positive integer")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        self.autosummarize = autosummarize
        self.pages_per_range = pages_per_range
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.autosummarize is not None:
<<<<<<< HEAD
            kwargs['autosummarize'] = self.autosummarize
        if self.pages_per_range is not None:
            kwargs['pages_per_range'] = self.pages_per_range
        return path, args, kwargs

    def check_supported(self, schema_editor):
        if self.autosummarize and not schema_editor.connection.features.has_brin_autosummarize:
            raise NotSupportedError('BRIN option autosummarize requires PostgreSQL 10+.')

    def get_with_params(self):
        with_params = []
        if self.autosummarize is not None:
            with_params.append('autosummarize = %s' % ('on' if self.autosummarize else 'off'))
        if self.pages_per_range is not None:
            with_params.append('pages_per_range = %d' % self.pages_per_range)
=======
            kwargs["autosummarize"] = self.autosummarize
        if self.pages_per_range is not None:
            kwargs["pages_per_range"] = self.pages_per_range
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.autosummarize is not None:
            with_params.append(
                "autosummarize = %s" % ("on" if self.autosummarize else "off")
            )
        if self.pages_per_range is not None:
            with_params.append("pages_per_range = %d" % self.pages_per_range)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return with_params


class BTreeIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'btree'
=======
    suffix = "btree"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *expressions, fillfactor=None, **kwargs):
        self.fillfactor = fillfactor
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.fillfactor is not None:
<<<<<<< HEAD
            kwargs['fillfactor'] = self.fillfactor
=======
            kwargs["fillfactor"] = self.fillfactor
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.fillfactor is not None:
<<<<<<< HEAD
            with_params.append('fillfactor = %d' % self.fillfactor)
=======
            with_params.append("fillfactor = %d" % self.fillfactor)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return with_params


class GinIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'gin'

    def __init__(self, *expressions, fastupdate=None, gin_pending_list_limit=None, **kwargs):
=======
    suffix = "gin"

    def __init__(
        self, *expressions, fastupdate=None, gin_pending_list_limit=None, **kwargs
    ):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        self.fastupdate = fastupdate
        self.gin_pending_list_limit = gin_pending_list_limit
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.fastupdate is not None:
<<<<<<< HEAD
            kwargs['fastupdate'] = self.fastupdate
        if self.gin_pending_list_limit is not None:
            kwargs['gin_pending_list_limit'] = self.gin_pending_list_limit
=======
            kwargs["fastupdate"] = self.fastupdate
        if self.gin_pending_list_limit is not None:
            kwargs["gin_pending_list_limit"] = self.gin_pending_list_limit
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.gin_pending_list_limit is not None:
<<<<<<< HEAD
            with_params.append('gin_pending_list_limit = %d' % self.gin_pending_list_limit)
        if self.fastupdate is not None:
            with_params.append('fastupdate = %s' % ('on' if self.fastupdate else 'off'))
=======
            with_params.append(
                "gin_pending_list_limit = %d" % self.gin_pending_list_limit
            )
        if self.fastupdate is not None:
            with_params.append("fastupdate = %s" % ("on" if self.fastupdate else "off"))
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return with_params


class GistIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'gist'
=======
    suffix = "gist"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *expressions, buffering=None, fillfactor=None, **kwargs):
        self.buffering = buffering
        self.fillfactor = fillfactor
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.buffering is not None:
<<<<<<< HEAD
            kwargs['buffering'] = self.buffering
        if self.fillfactor is not None:
            kwargs['fillfactor'] = self.fillfactor
=======
            kwargs["buffering"] = self.buffering
        if self.fillfactor is not None:
            kwargs["fillfactor"] = self.fillfactor
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.buffering is not None:
<<<<<<< HEAD
            with_params.append('buffering = %s' % ('on' if self.buffering else 'off'))
        if self.fillfactor is not None:
            with_params.append('fillfactor = %d' % self.fillfactor)
        return with_params

    def check_supported(self, schema_editor):
        if self.include and not schema_editor.connection.features.supports_covering_gist_indexes:
            raise NotSupportedError('Covering GiST indexes requires PostgreSQL 12+.')


class HashIndex(PostgresIndex):
    suffix = 'hash'
=======
            with_params.append("buffering = %s" % ("on" if self.buffering else "off"))
        if self.fillfactor is not None:
            with_params.append("fillfactor = %d" % self.fillfactor)
        return with_params


class HashIndex(PostgresIndex):
    suffix = "hash"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *expressions, fillfactor=None, **kwargs):
        self.fillfactor = fillfactor
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.fillfactor is not None:
<<<<<<< HEAD
            kwargs['fillfactor'] = self.fillfactor
=======
            kwargs["fillfactor"] = self.fillfactor
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.fillfactor is not None:
<<<<<<< HEAD
            with_params.append('fillfactor = %d' % self.fillfactor)
=======
            with_params.append("fillfactor = %d" % self.fillfactor)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return with_params


class SpGistIndex(PostgresIndex):
<<<<<<< HEAD
    suffix = 'spgist'
=======
    suffix = "spgist"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *expressions, fillfactor=None, **kwargs):
        self.fillfactor = fillfactor
        super().__init__(*expressions, **kwargs)

    def deconstruct(self):
        path, args, kwargs = super().deconstruct()
        if self.fillfactor is not None:
<<<<<<< HEAD
            kwargs['fillfactor'] = self.fillfactor
=======
            kwargs["fillfactor"] = self.fillfactor
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return path, args, kwargs

    def get_with_params(self):
        with_params = []
        if self.fillfactor is not None:
<<<<<<< HEAD
            with_params.append('fillfactor = %d' % self.fillfactor)
        return with_params


class OpClass(Func):
    template = '%(expressions)s %(name)s'
=======
            with_params.append("fillfactor = %d" % self.fillfactor)
        return with_params

    def check_supported(self, schema_editor):
        if (
            self.include
            and not schema_editor.connection.features.supports_covering_spgist_indexes
        ):
            raise NotSupportedError("Covering SP-GiST indexes require PostgreSQL 14+.")


class OpClass(Func):
    template = "%(expressions)s %(name)s"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, expression, name):
        super().__init__(expression, name=name)
