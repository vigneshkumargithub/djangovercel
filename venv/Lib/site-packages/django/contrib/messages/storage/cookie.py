import binascii
import json

from django.conf import settings
from django.contrib.messages.storage.base import BaseStorage, Message
from django.core import signing
from django.http import SimpleCookie
<<<<<<< HEAD
from django.utils.crypto import constant_time_compare, salted_hmac
=======
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
from django.utils.safestring import SafeData, mark_safe


class MessageEncoder(json.JSONEncoder):
    """
    Compactly serialize instances of the ``Message`` class as JSON.
    """
<<<<<<< HEAD
    message_key = '__json_message'
=======

    message_key = "__json_message"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def default(self, obj):
        if isinstance(obj, Message):
            # Using 0/1 here instead of False/True to produce more compact json
            is_safedata = 1 if isinstance(obj.message, SafeData) else 0
            message = [self.message_key, is_safedata, obj.level, obj.message]
<<<<<<< HEAD
            if obj.extra_tags:
=======
            if obj.extra_tags is not None:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                message.append(obj.extra_tags)
            return message
        return super().default(obj)


class MessageDecoder(json.JSONDecoder):
    """
    Decode JSON that includes serialized ``Message`` instances.
    """

    def process_messages(self, obj):
        if isinstance(obj, list) and obj:
            if obj[0] == MessageEncoder.message_key:
                if obj[1]:
                    obj[3] = mark_safe(obj[3])
                return Message(*obj[2:])
            return [self.process_messages(item) for item in obj]
        if isinstance(obj, dict):
<<<<<<< HEAD
            return {key: self.process_messages(value)
                    for key, value in obj.items()}
=======
            return {key: self.process_messages(value) for key, value in obj.items()}
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return obj

    def decode(self, s, **kwargs):
        decoded = super().decode(s, **kwargs)
        return self.process_messages(decoded)


<<<<<<< HEAD
class MessageSerializer:
    def dumps(self, obj):
        return json.dumps(
            obj,
            separators=(',', ':'),
            cls=MessageEncoder,
        ).encode('latin-1')

    def loads(self, data):
        return json.loads(data.decode('latin-1'), cls=MessageDecoder)
=======
class MessagePartSerializer:
    def dumps(self, obj):
        return [
            json.dumps(
                o,
                separators=(",", ":"),
                cls=MessageEncoder,
            )
            for o in obj
        ]


class MessagePartGatherSerializer:
    def dumps(self, obj):
        """
        The parameter is an already serialized list of Message objects. No need
        to serialize it again, only join the list together and encode it.
        """
        return ("[" + ",".join(obj) + "]").encode("latin-1")


class MessageSerializer:
    def loads(self, data):
        return json.loads(data.decode("latin-1"), cls=MessageDecoder)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


class CookieStorage(BaseStorage):
    """
    Store messages in a cookie.
    """
<<<<<<< HEAD
    cookie_name = 'messages'
=======

    cookie_name = "messages"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    # uwsgi's default configuration enforces a maximum size of 4kb for all the
    # HTTP headers. In order to leave some room for other cookies and headers,
    # restrict the session cookie to 1/2 of 4kb. See #18781.
    max_cookie_size = 2048
<<<<<<< HEAD
    not_finished = '__messagesnotfinished__'
    key_salt = 'django.contrib.messages'
=======
    not_finished = "__messagesnotfinished__"
    not_finished_json = json.dumps("__messagesnotfinished__")
    key_salt = "django.contrib.messages"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.signer = signing.get_cookie_signer(salt=self.key_salt)

    def _get(self, *args, **kwargs):
        """
        Retrieve a list of messages from the messages cookie. If the
        not_finished sentinel value is found at the end of the message list,
        remove it and return a result indicating that not all messages were
        retrieved by this storage.
        """
        data = self.request.COOKIES.get(self.cookie_name)
        messages = self._decode(data)
        all_retrieved = not (messages and messages[-1] == self.not_finished)
        if messages and not all_retrieved:
            # remove the sentinel value
            messages.pop()
        return messages, all_retrieved

    def _update_cookie(self, encoded_data, response):
        """
        Either set the cookie with the encoded data if there is any data to
        store, or delete the cookie.
        """
        if encoded_data:
            response.set_cookie(
<<<<<<< HEAD
                self.cookie_name, encoded_data,
=======
                self.cookie_name,
                encoded_data,
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                domain=settings.SESSION_COOKIE_DOMAIN,
                secure=settings.SESSION_COOKIE_SECURE or None,
                httponly=settings.SESSION_COOKIE_HTTPONLY or None,
                samesite=settings.SESSION_COOKIE_SAMESITE,
            )
        else:
            response.delete_cookie(
                self.cookie_name,
                domain=settings.SESSION_COOKIE_DOMAIN,
                samesite=settings.SESSION_COOKIE_SAMESITE,
            )

    def _store(self, messages, response, remove_oldest=True, *args, **kwargs):
        """
        Store the messages to a cookie and return a list of any messages which
        could not be stored.

        If the encoded data is larger than ``max_cookie_size``, remove
        messages until the data fits (these are the messages which are
        returned), and add the not_finished sentinel value to indicate as much.
        """
        unstored_messages = []
<<<<<<< HEAD
        encoded_data = self._encode(messages)
=======
        serialized_messages = MessagePartSerializer().dumps(messages)
        encoded_data = self._encode_parts(serialized_messages)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        if self.max_cookie_size:
            # data is going to be stored eventually by SimpleCookie, which
            # adds its own overhead, which we must account for.
            cookie = SimpleCookie()  # create outside the loop

<<<<<<< HEAD
            def stored_length(val):
                return len(cookie.value_encode(val)[1])

            while encoded_data and stored_length(encoded_data) > self.max_cookie_size:
                if remove_oldest:
                    unstored_messages.append(messages.pop(0))
                else:
                    unstored_messages.insert(0, messages.pop())
                encoded_data = self._encode(messages + [self.not_finished],
                                            encode_empty=unstored_messages)
        self._update_cookie(encoded_data, response)
        return unstored_messages

    def _legacy_hash(self, value):
        """
        # RemovedInDjango40Warning: pre-Django 3.1 hashes will be invalid.
        Create an HMAC/SHA1 hash based on the value and the project setting's
        SECRET_KEY, modified to make it unique for the present purpose.
        """
        # The class wide key salt is not reused here since older Django
        # versions had it fixed and making it dynamic would break old hashes if
        # self.key_salt is changed.
        key_salt = 'django.contrib.messages'
        return salted_hmac(key_salt, value).hexdigest()
=======
            def is_too_large_for_cookie(data):
                return data and len(cookie.value_encode(data)[1]) > self.max_cookie_size

            def compute_msg(some_serialized_msg):
                return self._encode_parts(
                    some_serialized_msg + [self.not_finished_json],
                    encode_empty=True,
                )

            if is_too_large_for_cookie(encoded_data):
                if remove_oldest:
                    idx = bisect_keep_right(
                        serialized_messages,
                        fn=lambda m: is_too_large_for_cookie(compute_msg(m)),
                    )
                    unstored_messages = messages[:idx]
                    encoded_data = compute_msg(serialized_messages[idx:])
                else:
                    idx = bisect_keep_left(
                        serialized_messages,
                        fn=lambda m: is_too_large_for_cookie(compute_msg(m)),
                    )
                    unstored_messages = messages[idx:]
                    encoded_data = compute_msg(serialized_messages[:idx])

        self._update_cookie(encoded_data, response)
        return unstored_messages

    def _encode_parts(self, messages, encode_empty=False):
        """
        Return an encoded version of the serialized messages list which can be
        stored as plain text.

        Since the data will be retrieved from the client-side, the encoded data
        also contains a hash to ensure that the data was not tampered with.
        """
        if messages or encode_empty:
            return self.signer.sign_object(
                messages, serializer=MessagePartGatherSerializer, compress=True
            )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _encode(self, messages, encode_empty=False):
        """
        Return an encoded version of the messages list which can be stored as
        plain text.

<<<<<<< HEAD
        Since the data will be retrieved from the client-side, the encoded data
        also contains a hash to ensure that the data was not tampered with.
        """
        if messages or encode_empty:
            return self.signer.sign_object(messages, serializer=MessageSerializer, compress=True)
=======
        Proxies MessagePartSerializer.dumps and _encoded_parts.
        """
        serialized_messages = MessagePartSerializer().dumps(messages)
        return self._encode_parts(serialized_messages, encode_empty=encode_empty)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _decode(self, data):
        """
        Safely decode an encoded text stream back into a list of messages.

        If the encoded text stream contained an invalid hash or was in an
        invalid format, return None.
        """
        if not data:
            return None
        try:
            return self.signer.unsign_object(data, serializer=MessageSerializer)
<<<<<<< HEAD
        # RemovedInDjango41Warning: when the deprecation ends, replace with:
        #
        # except (signing.BadSignature, json.JSONDecodeError):
        #     pass
        except signing.BadSignature:
            # RemovedInDjango40Warning: when the deprecation ends, replace
            # with:
            #   decoded = None.
            decoded = self._legacy_decode(data)
        except (binascii.Error, json.JSONDecodeError):
            decoded = self.signer.unsign(data)

        if decoded:
            # RemovedInDjango41Warning.
            try:
                return json.loads(decoded, cls=MessageDecoder)
            except json.JSONDecodeError:
                pass
=======
        except (signing.BadSignature, binascii.Error, json.JSONDecodeError):
            pass
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        # Mark the data as used (so it gets removed) since something was wrong
        # with the data.
        self.used = True
        return None

<<<<<<< HEAD
    def _legacy_decode(self, data):
        # RemovedInDjango40Warning: pre-Django 3.1 hashes will be invalid.
        bits = data.split('$', 1)
        if len(bits) == 2:
            hash_, value = bits
            if constant_time_compare(hash_, self._legacy_hash(value)):
                return value
        return None
=======

def bisect_keep_left(a, fn):
    """
    Find the index of the first element from the start of the array that
    verifies the given condition.
    The function is applied from the start of the array to the pivot.
    """
    lo = 0
    hi = len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if fn(a[: mid + 1]):
            hi = mid
        else:
            lo = mid + 1
    return lo


def bisect_keep_right(a, fn):
    """
    Find the index of the first element from the end of the array that verifies
    the given condition.
    The function is applied from the pivot to the end of array.
    """
    lo = 0
    hi = len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if fn(a[mid:]):
            lo = mid + 1
        else:
            hi = mid
    return lo
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
