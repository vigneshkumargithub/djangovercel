#
# The Python Imaging Library.
# $Id$
#
# IM Tools support for PIL
#
# history:
# 1996-05-27 fl   Created (read 8-bit images only)
# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.2)
#
# Copyright (c) Secret Labs AB 1997-2001.
# Copyright (c) Fredrik Lundh 1996-2001.
#
# See the README file for information on usage and redistribution.
#
<<<<<<< HEAD

=======
from __future__ import annotations
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

import re

from . import Image, ImageFile

#
# --------------------------------------------------------------------

<<<<<<< HEAD
field = re.compile(br"([a-z]*) ([^ \r\n]*)")
=======
field = re.compile(rb"([a-z]*) ([^ \r\n]*)")
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


##
# Image plugin for IM Tools images.


class ImtImageFile(ImageFile.ImageFile):
<<<<<<< HEAD

    format = "IMT"
    format_description = "IM Tools"

    def _open(self):

        # Quick rejection: if there's not a LF among the first
        # 100 bytes, this is (probably) not a text header.

        if b"\n" not in self.fp.read(100):
            raise SyntaxError("not an IM file")
        self.fp.seek(0)
=======
    format = "IMT"
    format_description = "IM Tools"

    def _open(self) -> None:
        # Quick rejection: if there's not a LF among the first
        # 100 bytes, this is (probably) not a text header.

        assert self.fp is not None

        buffer = self.fp.read(100)
        if b"\n" not in buffer:
            msg = "not an IM file"
            raise SyntaxError(msg)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        xsize = ysize = 0

        while True:
<<<<<<< HEAD

            s = self.fp.read(1)
=======
            if buffer:
                s = buffer[:1]
                buffer = buffer[1:]
            else:
                s = self.fp.read(1)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            if not s:
                break

            if s == b"\x0C":
<<<<<<< HEAD

                # image data begins
                self.tile = [
                    ("raw", (0, 0) + self.size, self.fp.tell(), (self.mode, 0, 1))
=======
                # image data begins
                self.tile = [
                    (
                        "raw",
                        (0, 0) + self.size,
                        self.fp.tell() - len(buffer),
                        (self.mode, 0, 1),
                    )
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                ]

                break

            else:
<<<<<<< HEAD

                # read key/value pair
                # FIXME: dangerous, may read whole file
                s = s + self.fp.readline()
=======
                # read key/value pair
                if b"\n" not in buffer:
                    buffer += self.fp.read(100)
                lines = buffer.split(b"\n")
                s += lines.pop(0)
                buffer = b"\n".join(lines)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
                if len(s) == 1 or len(s) > 100:
                    break
                if s[0] == ord(b"*"):
                    continue  # comment

                m = field.match(s)
                if not m:
                    break
                k, v = m.group(1, 2)
<<<<<<< HEAD
                if k == "width":
                    xsize = int(v)
                    self._size = xsize, ysize
                elif k == "height":
                    ysize = int(v)
                    self._size = xsize, ysize
                elif k == "pixel" and v == "n8":
                    self.mode = "L"
=======
                if k == b"width":
                    xsize = int(v)
                    self._size = xsize, ysize
                elif k == b"height":
                    ysize = int(v)
                    self._size = xsize, ysize
                elif k == b"pixel" and v == b"n8":
                    self._mode = "L"
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581


#
# --------------------------------------------------------------------

Image.register_open(ImtImageFile.format, ImtImageFile)

#
# no extension registered (".im" is simply too common)
