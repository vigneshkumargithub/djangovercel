#
# The Python Imaging Library
# Pillow fork
#
# Python implementation of the PixelAccess Object
#
# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.
# Copyright (c) 1995-2009 by Fredrik Lundh.
# Copyright (c) 2013 Eric Soroos
#
# See the README file for information on usage and redistribution
#

# Notes:
#
<<<<<<< HEAD
#  * Implements the pixel access object following Access.
#  * Does not implement the line functions, as they don't appear to be used
=======
#  * Implements the pixel access object following Access.c
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
#  * Taking only the tuple form, which is used from python.
#    * Fill.c uses the integer form, but it's still going to use the old
#      Access.c implementation.
#
<<<<<<< HEAD

import logging
import sys

=======
from __future__ import annotations

import logging
import sys
from typing import TYPE_CHECKING

from ._deprecate import deprecate

FFI: type
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
try:
    from cffi import FFI

    defs = """
    struct Pixel_RGBA {
        unsigned char r,g,b,a;
    };
    struct Pixel_I16 {
        unsigned char l,r;
    };
    """
    ffi = FFI()
    ffi.cdef(defs)
except ImportError as ex:
    # Allow error import for doc purposes, but error out when accessing
    # anything in core.
<<<<<<< HEAD
    from ._util import deferred_error

    FFI = ffi = deferred_error(ex)

logger = logging.getLogger(__name__)


class PyAccess:
    def __init__(self, img, readonly=False):
=======
    from ._util import DeferredError

    FFI = ffi = DeferredError.new(ex)

logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from . import Image


class PyAccess:
    def __init__(self, img: Image.Image, readonly: bool = False) -> None:
        deprecate("PyAccess", 11)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        vals = dict(img.im.unsafe_ptrs)
        self.readonly = readonly
        self.image8 = ffi.cast("unsigned char **", vals["image8"])
        self.image32 = ffi.cast("int **", vals["image32"])
        self.image = ffi.cast("unsigned char **", vals["image"])
        self.xsize, self.ysize = img.im.size
        self._img = img

        # Keep pointer to im object to prevent dereferencing.
        self._im = img.im
<<<<<<< HEAD
        if self._im.mode == "P":
=======
        if self._im.mode in ("P", "PA"):
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
            self._palette = img.palette

        # Debugging is polluting test traces, only useful here
        # when hacking on PyAccess
        # logger.debug("%s", vals)
        self._post_init()

<<<<<<< HEAD
    def _post_init(self):
        pass

    def __setitem__(self, xy, color):
        """
        Modifies the pixel at x,y. The color is given as a single
        numerical value for single band images, and a tuple for
        multi-band images
=======
    def _post_init(self) -> None:
        pass

    def __setitem__(
        self,
        xy: tuple[int, int] | list[int],
        color: float | tuple[int, ...] | list[int],
    ) -> None:
        """
        Modifies the pixel at x,y. The color is given as a single
        numerical value for single band images, and a tuple for
        multi-band images. In addition to this, RGB and RGBA tuples
        are accepted for P and PA images.
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        :param xy: The pixel coordinate, given as (x, y). See
           :ref:`coordinate-system`.
        :param color: The pixel value.
        """
        if self.readonly:
<<<<<<< HEAD
            raise ValueError("Attempt to putpixel a read only image")
=======
            msg = "Attempt to putpixel a read only image"
            raise ValueError(msg)
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        (x, y) = xy
        if x < 0:
            x = self.xsize + x
        if y < 0:
            y = self.ysize + y
        (x, y) = self.check_xy((x, y))

        if (
<<<<<<< HEAD
            self._im.mode == "P"
            and isinstance(color, (list, tuple))
            and len(color) in [3, 4]
        ):
            # RGB or RGBA value for a P image
            color = self._palette.getcolor(color, self._img)

        return self.set_pixel(x, y, color)

    def __getitem__(self, xy):
=======
            self._im.mode in ("P", "PA")
            and isinstance(color, (list, tuple))
            and len(color) in [3, 4]
        ):
            # RGB or RGBA value for a P or PA image
            if self._im.mode == "PA":
                alpha = color[3] if len(color) == 4 else 255
                color = color[:3]
            palette_index = self._palette.getcolor(color, self._img)
            color = (palette_index, alpha) if self._im.mode == "PA" else palette_index

        return self.set_pixel(x, y, color)

    def __getitem__(self, xy: tuple[int, int] | list[int]) -> float | tuple[int, ...]:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        """
        Returns the pixel at x,y. The pixel is returned as a single
        value for single band images or a tuple for multiple band
        images

        :param xy: The pixel coordinate, given as (x, y). See
          :ref:`coordinate-system`.
        :returns: a pixel value for single band images, a tuple of
          pixel values for multiband images.
        """
        (x, y) = xy
        if x < 0:
            x = self.xsize + x
        if y < 0:
            y = self.ysize + y
        (x, y) = self.check_xy((x, y))
        return self.get_pixel(x, y)

    putpixel = __setitem__
    getpixel = __getitem__

<<<<<<< HEAD
    def check_xy(self, xy):
        (x, y) = xy
        if not (0 <= x < self.xsize and 0 <= y < self.ysize):
            raise ValueError("pixel location out of range")
        return xy


class _PyAccess32_2(PyAccess):
    """ PA, LA, stored in first and last bytes of a 32 bit word """
=======
    def check_xy(self, xy: tuple[int, int]) -> tuple[int, int]:
        (x, y) = xy
        if not (0 <= x < self.xsize and 0 <= y < self.ysize):
            msg = "pixel location out of range"
            raise ValueError(msg)
        return xy

    def get_pixel(self, x: int, y: int) -> float | tuple[int, ...]:
        raise NotImplementedError()

    def set_pixel(
        self, x: int, y: int, color: float | tuple[int, ...] | list[int]
    ) -> None:
        raise NotImplementedError()


class _PyAccess32_2(PyAccess):
    """PA, LA, stored in first and last bytes of a 32 bit word"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)

<<<<<<< HEAD
    def get_pixel(self, x, y):
        pixel = self.pixels[y][x]
        return (pixel.r, pixel.a)
=======
    def get_pixel(self, x: int, y: int) -> tuple[int, int]:
        pixel = self.pixels[y][x]
        return pixel.r, pixel.a
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def set_pixel(self, x, y, color):
        pixel = self.pixels[y][x]
        # tuple
        pixel.r = min(color[0], 255)
        pixel.a = min(color[1], 255)


class _PyAccess32_3(PyAccess):
<<<<<<< HEAD
    """ RGB and friends, stored in the first three bytes of a 32 bit word """
=======
    """RGB and friends, stored in the first three bytes of a 32 bit word"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)

<<<<<<< HEAD
    def get_pixel(self, x, y):
        pixel = self.pixels[y][x]
        return (pixel.r, pixel.g, pixel.b)
=======
    def get_pixel(self, x: int, y: int) -> tuple[int, int, int]:
        pixel = self.pixels[y][x]
        return pixel.r, pixel.g, pixel.b
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def set_pixel(self, x, y, color):
        pixel = self.pixels[y][x]
        # tuple
        pixel.r = min(color[0], 255)
        pixel.g = min(color[1], 255)
        pixel.b = min(color[2], 255)
        pixel.a = 255


class _PyAccess32_4(PyAccess):
<<<<<<< HEAD
    """ RGBA etc, all 4 bytes of a 32 bit word """
=======
    """RGBA etc, all 4 bytes of a 32 bit word"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("struct Pixel_RGBA **", self.image32)

<<<<<<< HEAD
    def get_pixel(self, x, y):
        pixel = self.pixels[y][x]
        return (pixel.r, pixel.g, pixel.b, pixel.a)
=======
    def get_pixel(self, x: int, y: int) -> tuple[int, int, int, int]:
        pixel = self.pixels[y][x]
        return pixel.r, pixel.g, pixel.b, pixel.a
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def set_pixel(self, x, y, color):
        pixel = self.pixels[y][x]
        # tuple
        pixel.r = min(color[0], 255)
        pixel.g = min(color[1], 255)
        pixel.b = min(color[2], 255)
        pixel.a = min(color[3], 255)


class _PyAccess8(PyAccess):
<<<<<<< HEAD
    """ 1, L, P, 8 bit images stored as uint8 """
=======
    """1, L, P, 8 bit images stored as uint8"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = self.image8

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return self.pixels[y][x]

    def set_pixel(self, x, y, color):
        try:
            # integer
            self.pixels[y][x] = min(color, 255)
        except TypeError:
            # tuple
            self.pixels[y][x] = min(color[0], 255)


class _PyAccessI16_N(PyAccess):
<<<<<<< HEAD
    """ I;16 access, native bitendian without conversion """
=======
    """I;16 access, native bitendian without conversion"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("unsigned short **", self.image)

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return self.pixels[y][x]

    def set_pixel(self, x, y, color):
        try:
            # integer
            self.pixels[y][x] = min(color, 65535)
        except TypeError:
            # tuple
            self.pixels[y][x] = min(color[0], 65535)


class _PyAccessI16_L(PyAccess):
<<<<<<< HEAD
    """ I;16L access, with conversion """
=======
    """I;16L access, with conversion"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("struct Pixel_I16 **", self.image)

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        pixel = self.pixels[y][x]
        return pixel.l + pixel.r * 256

    def set_pixel(self, x, y, color):
        pixel = self.pixels[y][x]
        try:
            color = min(color, 65535)
        except TypeError:
            color = min(color[0], 65535)

<<<<<<< HEAD
        pixel.l = color & 0xFF  # noqa: E741
=======
        pixel.l = color & 0xFF
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        pixel.r = color >> 8


class _PyAccessI16_B(PyAccess):
<<<<<<< HEAD
    """ I;16B access, with conversion """
=======
    """I;16B access, with conversion"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("struct Pixel_I16 **", self.image)

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        pixel = self.pixels[y][x]
        return pixel.l * 256 + pixel.r

    def set_pixel(self, x, y, color):
        pixel = self.pixels[y][x]
        try:
            color = min(color, 65535)
        except Exception:
            color = min(color[0], 65535)

<<<<<<< HEAD
        pixel.l = color >> 8  # noqa: E741
=======
        pixel.l = color >> 8
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        pixel.r = color & 0xFF


class _PyAccessI32_N(PyAccess):
<<<<<<< HEAD
    """ Signed Int32 access, native endian """
=======
    """Signed Int32 access, native endian"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = self.image32

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return self.pixels[y][x]

    def set_pixel(self, x, y, color):
        self.pixels[y][x] = color


class _PyAccessI32_Swap(PyAccess):
<<<<<<< HEAD
    """ I;32L/B access, with byteswapping conversion """
=======
    """I;32L/B access, with byteswapping conversion"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = self.image32

    def reverse(self, i):
        orig = ffi.new("int *", i)
        chars = ffi.cast("unsigned char *", orig)
        chars[0], chars[1], chars[2], chars[3] = chars[3], chars[2], chars[1], chars[0]
        return ffi.cast("int *", chars)[0]

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> int:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return self.reverse(self.pixels[y][x])

    def set_pixel(self, x, y, color):
        self.pixels[y][x] = self.reverse(color)


class _PyAccessF(PyAccess):
<<<<<<< HEAD
    """ 32 bit float access """
=======
    """32 bit float access"""
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    def _post_init(self, *args, **kwargs):
        self.pixels = ffi.cast("float **", self.image32)

<<<<<<< HEAD
    def get_pixel(self, x, y):
=======
    def get_pixel(self, x: int, y: int) -> float:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
        return self.pixels[y][x]

    def set_pixel(self, x, y, color):
        try:
            # not a tuple
            self.pixels[y][x] = color
        except TypeError:
            # tuple
            self.pixels[y][x] = color[0]


mode_map = {
    "1": _PyAccess8,
    "L": _PyAccess8,
    "P": _PyAccess8,
<<<<<<< HEAD
=======
    "I;16N": _PyAccessI16_N,
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    "LA": _PyAccess32_2,
    "La": _PyAccess32_2,
    "PA": _PyAccess32_2,
    "RGB": _PyAccess32_3,
    "LAB": _PyAccess32_3,
    "HSV": _PyAccess32_3,
    "YCbCr": _PyAccess32_3,
    "RGBA": _PyAccess32_4,
    "RGBa": _PyAccess32_4,
    "RGBX": _PyAccess32_4,
    "CMYK": _PyAccess32_4,
    "F": _PyAccessF,
    "I": _PyAccessI32_N,
}

if sys.byteorder == "little":
    mode_map["I;16"] = _PyAccessI16_N
    mode_map["I;16L"] = _PyAccessI16_N
    mode_map["I;16B"] = _PyAccessI16_B

    mode_map["I;32L"] = _PyAccessI32_N
    mode_map["I;32B"] = _PyAccessI32_Swap
else:
    mode_map["I;16"] = _PyAccessI16_L
    mode_map["I;16L"] = _PyAccessI16_L
    mode_map["I;16B"] = _PyAccessI16_N

    mode_map["I;32L"] = _PyAccessI32_Swap
    mode_map["I;32B"] = _PyAccessI32_N


<<<<<<< HEAD
def new(img, readonly=False):
=======
def new(img: Image.Image, readonly: bool = False) -> PyAccess | None:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    access_type = mode_map.get(img.mode, None)
    if not access_type:
        logger.debug("PyAccess Not Implemented: %s", img.mode)
        return None
    return access_type(img, readonly)
