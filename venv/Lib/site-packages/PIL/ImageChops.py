#
# The Python Imaging Library.
# $Id$
#
# standard channel operations
#
# History:
# 1996-03-24 fl   Created
# 1996-08-13 fl   Added logical operations (for "1" images)
# 2000-10-12 fl   Added offset method (from Image.py)
#
# Copyright (c) 1997-2000 by Secret Labs AB
# Copyright (c) 1996-2000 by Fredrik Lundh
#
# See the README file for information on usage and redistribution.
#

<<<<<<< HEAD
from . import Image


def constant(image, value):
    """Fill a channel with a given grey level.
=======
from __future__ import annotations

from . import Image


def constant(image: Image.Image, value: int) -> Image.Image:
    """Fill a channel with a given gray level.
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

    :rtype: :py:class:`~PIL.Image.Image`
    """

    return Image.new("L", image.size, value)


<<<<<<< HEAD
def duplicate(image):
=======
def duplicate(image: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.

    :rtype: :py:class:`~PIL.Image.Image`
    """

    return image.copy()


<<<<<<< HEAD
def invert(image):
    """
    Invert an image (channel).

    .. code-block:: python
=======
def invert(image: Image.Image) -> Image.Image:
    """
    Invert an image (channel). ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = MAX - image

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image.load()
    return image._new(image.im.chop_invert())


<<<<<<< HEAD
def lighter(image1, image2):
    """
    Compares the two images, pixel by pixel, and returns a new image containing
    the lighter values.

    .. code-block:: python
=======
def lighter(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """
    Compares the two images, pixel by pixel, and returns a new image containing
    the lighter values. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = max(image1, image2)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_lighter(image2.im))


<<<<<<< HEAD
def darker(image1, image2):
    """
    Compares the two images, pixel by pixel, and returns a new image containing
    the darker values.

    .. code-block:: python
=======
def darker(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """
    Compares the two images, pixel by pixel, and returns a new image containing
    the darker values. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = min(image1, image2)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_darker(image2.im))


<<<<<<< HEAD
def difference(image1, image2):
    """
    Returns the absolute value of the pixel-by-pixel difference between the two
    images.

    .. code-block:: python
=======
def difference(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """
    Returns the absolute value of the pixel-by-pixel difference between the two
    images. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = abs(image1 - image2)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_difference(image2.im))


<<<<<<< HEAD
def multiply(image1, image2):
=======
def multiply(image1: Image.Image, image2: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """
    Superimposes two images on top of each other.

    If you multiply an image with a solid black image, the result is black. If
<<<<<<< HEAD
    you multiply with a solid white image, the image is unaffected.

    .. code-block:: python
=======
    you multiply with a solid white image, the image is unaffected. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = image1 * image2 / MAX

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_multiply(image2.im))


<<<<<<< HEAD
def screen(image1, image2):
    """
    Superimposes two inverted images on top of each other.

    .. code-block:: python
=======
def screen(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """
    Superimposes two inverted images on top of each other. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = MAX - ((MAX - image1) * (MAX - image2) / MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_screen(image2.im))


<<<<<<< HEAD
def soft_light(image1, image2):
=======
def soft_light(image1: Image.Image, image2: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """
    Superimposes two images on top of each other using the Soft Light algorithm

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_soft_light(image2.im))


<<<<<<< HEAD
def hard_light(image1, image2):
=======
def hard_light(image1: Image.Image, image2: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """
    Superimposes two images on top of each other using the Hard Light algorithm

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_hard_light(image2.im))


<<<<<<< HEAD
def overlay(image1, image2):
=======
def overlay(image1: Image.Image, image2: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """
    Superimposes two images on top of each other using the Overlay algorithm

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_overlay(image2.im))


<<<<<<< HEAD
def add(image1, image2, scale=1.0, offset=0):
    """
    Adds two images, dividing the result by scale and adding the
    offset. If omitted, scale defaults to 1.0, and offset to 0.0.

    .. code-block:: python
=======
def add(
    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0
) -> Image.Image:
    """
    Adds two images, dividing the result by scale and adding the
    offset. If omitted, scale defaults to 1.0, and offset to 0.0. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 + image2) / scale + offset)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_add(image2.im, scale, offset))


<<<<<<< HEAD
def subtract(image1, image2, scale=1.0, offset=0):
    """
    Subtracts two images, dividing the result by scale and adding the offset.
    If omitted, scale defaults to 1.0, and offset to 0.0.

    .. code-block:: python
=======
def subtract(
    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0
) -> Image.Image:
    """
    Subtracts two images, dividing the result by scale and adding the offset.
    If omitted, scale defaults to 1.0, and offset to 0.0. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 - image2) / scale + offset)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_subtract(image2.im, scale, offset))


<<<<<<< HEAD
def add_modulo(image1, image2):
    """Add two images, without clipping the result.

    .. code-block:: python
=======
def add_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """Add two images, without clipping the result. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 + image2) % MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_add_modulo(image2.im))


<<<<<<< HEAD
def subtract_modulo(image1, image2):
    """Subtract two images, without clipping the result.

    .. code-block:: python
=======
def subtract_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """Subtract two images, without clipping the result. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 - image2) % MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_subtract_modulo(image2.im))


<<<<<<< HEAD
def logical_and(image1, image2):
=======
def logical_and(image1: Image.Image, image2: Image.Image) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """Logical AND between two images.

    Both of the images must have mode "1". If you would like to perform a
    logical AND on an image with a mode other than "1", try
    :py:meth:`~PIL.ImageChops.multiply` instead, using a black-and-white mask
<<<<<<< HEAD
    as the second image.

    .. code-block:: python
=======
    as the second image. ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 and image2) % MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_and(image2.im))


<<<<<<< HEAD
def logical_or(image1, image2):
    """Logical OR between two images.

    Both of the images must have mode "1".

    .. code-block:: python
=======
def logical_or(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """Logical OR between two images.

    Both of the images must have mode "1". ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((image1 or image2) % MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_or(image2.im))


<<<<<<< HEAD
def logical_xor(image1, image2):
    """Logical XOR between two images.

    Both of the images must have mode "1".

    .. code-block:: python
=======
def logical_xor(image1: Image.Image, image2: Image.Image) -> Image.Image:
    """Logical XOR between two images.

    Both of the images must have mode "1". ::
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581

        out = ((bool(image1) != bool(image2)) % MAX)

    :rtype: :py:class:`~PIL.Image.Image`
    """

    image1.load()
    image2.load()
    return image1._new(image1.im.chop_xor(image2.im))


<<<<<<< HEAD
def blend(image1, image2, alpha):
=======
def blend(image1: Image.Image, image2: Image.Image, alpha: float) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """Blend images using constant transparency weight. Alias for
    :py:func:`PIL.Image.blend`.

    :rtype: :py:class:`~PIL.Image.Image`
    """

    return Image.blend(image1, image2, alpha)


<<<<<<< HEAD
def composite(image1, image2, mask):
=======
def composite(
    image1: Image.Image, image2: Image.Image, mask: Image.Image
) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """Create composite using transparency mask. Alias for
    :py:func:`PIL.Image.composite`.

    :rtype: :py:class:`~PIL.Image.Image`
    """

    return Image.composite(image1, image2, mask)


<<<<<<< HEAD
def offset(image, xoffset, yoffset=None):
=======
def offset(image: Image.Image, xoffset: int, yoffset: int | None = None) -> Image.Image:
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    """Returns a copy of the image where data has been offset by the given
    distances. Data wraps around the edges. If ``yoffset`` is omitted, it
    is assumed to be equal to ``xoffset``.

<<<<<<< HEAD
=======
    :param image: Input image.
>>>>>>> 32e7214c1350fb4a88064960159c92207483e581
    :param xoffset: The horizontal distance.
    :param yoffset: The vertical distance.  If omitted, both
        distances are set to the same value.
    :rtype: :py:class:`~PIL.Image.Image`
    """

    if yoffset is None:
        yoffset = xoffset
    image.load()
    return image._new(image.im.offset(xoffset, yoffset))
